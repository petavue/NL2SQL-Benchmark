{'geo': [{'question': 'what is the city with the smallest population', 'sql_query': 'SELECT city_name FROM city WHERE population  =  ( SELECT MIN ( population ) FROM city );', 'db_id': 'geo', 'hardness': 'hard', 'cot': '1. The SQL query is selecting the `city_name` from the `city` table.\n2. It uses a subquery to find the minimum population value in the `population` column of the `city` table.\n3. The subquery `SELECT MIN(population) FROM city` calculates the minimum population value among all cities.\n4. The main query then filters the cities by comparing the `population` column with the result of the subquery, thus retrieving the city with the smallest population.\n5. Finally, the query returns the name of the city with the smallest population.'}, {'question': 'what are major rivers in illinois', 'sql_query': 'SELECT river_name FROM river WHERE LENGTH  >  750 AND traverse  =  "illinois";', 'db_id': 'geo', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the river_name from the `river` table.\n2. It is filtering the results based on two conditions:\n   a. The length of the river (`LENGTH`) should be greater than 750.\n   b. The river should traverse the state of Illinois (`traverse = "illinois"`).\n3. The query will return a list of major rivers in Illinois that have a length greater than 750.'}], 'cre_Doc_Control_Systems': [{'question': "List the employees who have not showed up in any circulation history of documents. List the employee's name.", 'sql_query': 'SELECT employee_name FROM Employees EXCEPT SELECT Employees.employee_name FROM Employees JOIN Circulation_History ON Circulation_History.employee_id = Employees.employee_id', 'db_id': 'cre_Doc_Control_Systems', 'hardness': 'hard', 'cot': 'The SQL query starts by selecting the employee names from the Employees table. It then uses the EXCEPT keyword to remove from this list the employee names that are obtained by joining the Employees table with the Circulation_History table on the employee_id column. This ensures that only the employees who have not showed up in any circulation history of documents are included in the final result.'}, {'question': 'List the document ids for any documents with the status code done and the type code paper.', 'sql_query': 'SELECT document_id FROM Documents WHERE document_status_code = "done" AND document_type_code = "Paper";', 'db_id': 'cre_Doc_Control_Systems', 'hardness': 'medium', 'cot': '- Filter the `Documents` table to only include rows where the `document_status_code` is "done".\n- Further filter the results to only include rows where the `document_type_code` is "Paper".\n- Select and display the `document_id` from the filtered rows as the final result.'}], 'student_transcripts_tracking': [{'question': 'Which semesters do not have any student enrolled? List the semester name.', 'sql_query': 'SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment )', 'db_id': 'student_transcripts_tracking', 'hardness': 'hard', 'cot': '1. The SQL query selects the `semester_name` from the `Semesters` table.\n2. It uses a subquery to filter out semesters that have at least one student enrolled in them.\n3. The subquery selects `semester_id` from the `Student_Enrolment` table.\n4. The main query then returns the `semester_name` for semesters whose `semester_id` is not found in the result of the subquery.\n5. This means that the query will list semesters that do not have any students enrolled in them.'}, {'question': 'What is the department description for the one whose name has the word computer?', 'sql_query': "SELECT department_description FROM Departments WHERE department_name LIKE '%computer%'", 'db_id': 'student_transcripts_tracking', 'hardness': 'medium', 'cot': '1. The SQL query is a SELECT statement that retrieves the `department_description` from the `Departments` table.\n2. The condition used in the WHERE clause is `department_name LIKE \'%computer%\'`, which means it will search for department names that contain the word "computer" anywhere in their name.\n3. The query will return the `department_description` for the department(s) whose name includes the word "computer" in a case-insensitive manner due to the `%` wildcard characters used before and after the word "computer" in the LIKE clause.'}], 'product_catalog': [{'question': 'Find the catalog publisher that has the most catalogs.', 'sql_query': 'SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1', 'db_id': 'product_catalog', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `catalog_publisher` column from the `Catalogs` table.\n2. It then groups the results by the `catalog_publisher` column using the `GROUP BY` clause. This groups the rows with the same `catalog_publisher` value together.\n3. Next, it uses the `COUNT(*)` function to count the number of catalogs for each `catalog_publisher`.\n4. The `ORDER BY count(*) DESC` arranges the results in descending order based on the count of catalogs for each `catalog_publisher`. This means that the `catalog_publisher` with the highest count of catalogs will appear first.\n5. Finally, the query limits the result to only the first row using `LIMIT 1`, which ensures that we only retrieve the `catalog_publisher` that has the most catalogs.'}, {'question': 'Which catalog contents have length below 3 or above 5? Find the catalog entry names.', 'sql_query': 'SELECT catalog_entry_name FROM catalog_contents WHERE LENGTH  <  3 OR width  >  5', 'db_id': 'product_catalog', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the `catalog_entry_name` from the `catalog_contents` table.\n2. The condition specified in the `WHERE` clause is checking for catalog entries whose length is below 3 OR width is above 5.\n3. To perform this query, the lengths and widths of the catalog contents need to be compared to the specified values (3 for below and 5 for above).\n4. The query will retrieve the catalog entry names that meet the specified criteria of having a length below 3 or a width above 5 from the `catalog_contents` table.'}], 'wta_1': [{'question': 'Find the year that has the most number of matches.', 'sql_query': 'SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1', 'db_id': 'wta_1', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the `YEAR` column from the `matches` table.\n- It then groups the selected data by the `YEAR` column using the `GROUP BY` clause. This groups the rows by the year they belong to.\n- The `ORDER BY count(*) DESC` part of the query arranges the grouped data in descending order of the count of matches for each year. This count is calculated using the `count(*)` function.\n- Finally, the `LIMIT 1` clause ensures that only the first row of the result set is returned, which corresponds to the year with the most number of matches.'}, {'question': 'Find the number of players for each hand type.', 'sql_query': 'SELECT count(*) ,  hand FROM players GROUP BY hand', 'db_id': 'wta_1', 'hardness': 'medium', 'cot': '1. Start by selecting the columns we are interested in i.e., count of players and hand type from the players table.\n2. Group the data by the hand column to group players based on their hand type.\n3. Use the COUNT() function to calculate the number of players in each group.\n4. Finally, display the count of players for each hand type by executing the query.'}], 'insurance_and_eClaims': [{'question': 'What are the names of the customers and staff members?', 'sql_query': 'SELECT customer_details FROM customers UNION SELECT staff_details FROM staff', 'db_id': 'insurance_and_eClaims', 'hardness': 'hard', 'cot': 'To answer the question "What are the names of the customers and staff members?", we need to retrieve the names of the customers and staff members from the database. \nTo do this, we use a UNION operator in the SQL query. \nThe UNION operator is used to combine the result set of two or more SELECT statements. It removes duplicate rows between the various SELECT statements.\nIn this case, the query selects the Customer_Details from the Customers table and the Staff_Details from the Staff table. \nBy using the UNION operator, the query merges the result sets of the two SELECT statements and returns a single result set containing the names of both customers and staff members without duplicates.'}, {'question': 'What are the total amount and average amount paid in claim headers?', 'sql_query': 'SELECT sum(amount_piad) ,  avg(amount_piad) FROM claim_headers', 'db_id': 'insurance_and_eClaims', 'hardness': 'medium', 'cot': 'To answer the question "What are the total amount and average amount paid in claim headers?", the SQL query selects the sum of the \'amount_paid\' column and the average of the \'amount_paid\' column from the \'claim_headers\' table. The SUM function calculates the total amount paid in all claim headers, while the AVG function calculates the average amount paid in all claim headers. This query provides a concise way to retrieve these two aggregated values from the database.'}], 'document_management': [{'question': 'What are the usernames and passwords of users that have the most common role?', 'sql_query': 'SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1', 'db_id': 'document_management', 'hardness': 'hard', 'cot': '1. The SQL query selects the `user_name` and `password` columns from the `Users` table.\n2. The query groups the results by the `role_code` column using the `GROUP BY` clause.\n3. It then orders the groups by the count of occurrences (number of users) in each group in descending order using `ORDER BY count(*) DESC`.\n4. Finally, it selects only the first row (group) after ordering using `LIMIT 1`, which means it will return the usernames and passwords of users who have the most common role.'}, {'question': 'Find the number of users in each role.', 'sql_query': 'SELECT count(*) ,  role_code FROM users GROUP BY role_code', 'db_id': 'document_management', 'hardness': 'medium', 'cot': '1. The SQL query selects the count of records and the role_code column from the Users table.\n2. It groups the results by the role_code column.\n3. The COUNT(*) function is used to count the number of users in each role.\n4. The GROUP BY clause is used to group the results by the role_code column, so the count is calculated for each unique role_code.\n5. The query will return the number of users in each role as the output.'}], 'club_1': [{'question': 'Count the number of members in club "Bootup Baltimore" whose age is below 18.', 'sql_query': 'SELECT count(*) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid JOIN student AS t3 ON t2.stuid  =  t3.stuid WHERE t1.clubname  =  "Bootup Baltimore" AND t3.age  <  18', 'db_id': 'club_1', 'hardness': 'hard', 'cot': '1. **Retrieve the count**: The SQL query starts by selecting the count of records that meet certain conditions from the tables Student, Club, and Member_of_club.\n\n2. **Joining tables**: The query then joins the tables Club, Member_of_club, and Student using their respective keys to establish relationships between them. This allows for retrieving columns from all three tables based on the specified conditions.\n\n3. **Filtering based on ClubName**: The query specifies that only records related to the club with the name "Bootup Baltimore" should be considered. This condition is applied through the WHERE clause.\n\n4. **Filtering based on Age**: Another condition is imposed on the Student table where only students with an age below 18 are included. This condition is applied through the WHERE clause as well.\n\n5. **Final Result**: By executing this query, we will count the number of members in the "Bootup Baltimore" club who are below the age of 18 by navigating through the relationships defined in the database schema.'}, {'question': 'How many different roles are there in the club "Bootup Baltimore"?', 'sql_query': 'SELECT count(DISTINCT t2.position) FROM club AS t1 JOIN member_of_club AS t2 ON t1.clubid  =  t2.clubid WHERE t1.clubname  =  "Bootup Baltimore"', 'db_id': 'club_1', 'hardness': 'medium', 'cot': '1. We are selecting the count of distinct positions from the "member_of_club" table (aliased as t2) by joining it with the "club" table (aliased as t1) on the clubid to match the records.\n2. We are filtering the clubs by the clubname "Bootup Baltimore" in the WHERE clause to include only the members of the "Bootup Baltimore" club in the result.\n3. By counting the distinct positions of members in the "Bootup Baltimore" club, we can determine how many different roles exist within that particular club.'}], 'phone_1': [{'question': 'Find the names of the chip models that are not used by any phone with full accreditation type.', 'sql_query': "SELECT model_name FROM chip_model EXCEPT SELECT chip_model FROM phone WHERE Accreditation_type  =  'Full'", 'db_id': 'phone_1', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the column "model_name" from the "chip_model" table.\n2. It then uses the EXCEPT keyword to exclude any chip models that are used by phones with full accreditation type.\n3. This exclusion is done by selecting the column "chip_model" from the "phone" table WHERE the Accreditation_type is \'Full\'.\n4. The query will return the names of chip models that are not used by any phone with full accreditation type.'}, {'question': 'Find the Char cells, Pixels and Hardware colours for the screen of the phone whose hardware model name is "LG-P760".', 'sql_query': 'SELECT T1.Char_cells ,  T1.Pixels ,  T1.Hardware_colours FROM screen_mode AS T1 JOIN phone AS T2 ON T1.Graphics_mode = T2.screen_mode WHERE T2.Hardware_Model_name = "LG-P760";', 'db_id': 'phone_1', 'hardness': 'medium', 'cot': '- The SQL query starts by selecting the columns Char cells, Pixels, and Hardware colours from the screen_mode table, aliased as T1.\n- It then performs an inner join with the phone table, aliased as T2, using the condition T1.Graphics_mode = T2.screen_mode.\n- The join is based on matching the Graphics_mode in the screen_mode table with the screen_mode in the phone table.\n- The WHERE clause filters the rows from the joined result where the Hardware_Model_name in the phone table is equal to "LG-P760", which is the specific hardware model name we are looking for.\n- Finally, the query retrieves the Char cells, Pixels, and Hardware colours for the screen associated with the phone hardware model named "LG-P760".'}], 'soccer_2': [{'question': 'In which state is the college that Charles attends?', 'sql_query': "SELECT T1.state FROM college AS T1 JOIN tryout AS T2 ON T1.cName  =  T2.cName JOIN player AS T3 ON T2.pID  =  T3.pID WHERE T3.pName  =  'Charles'", 'db_id': 'soccer_2', 'hardness': 'hard', 'cot': "- We start by selecting data from the tables `College`, `Tryout`, and `Player`.\n- We join the tables `College` and `Tryout` on the common column `cName` to get the college information related to tryouts.\n- We then join the result of the previous join with the `Player` table on the common column `pID` to get player information.\n- We filter the result by specifying the player's name as 'Charles' using the condition `WHERE T3.pName = 'Charles'`.\n- Finally, the query selects the state (`T1.state`) of the college where Charles attends tryouts."}, {'question': 'What is the name of the school with smallest enrollment size per state?', 'sql_query': 'SELECT cName ,  state ,  min(enr) FROM college GROUP BY state', 'db_id': 'soccer_2', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the columns `cName`, `state`, and `min(enr)` from the `College` table.\n2. The query is grouping the results by the column `state`.\n3. By using the `min(enr)` function, the query will retrieve the smallest enrollment size for each state.\n4. The result will display the name of the school (`cName`) along with the state and the smallest enrollment size for each state.'}], 'wrestler': [{'question': 'Which reign is the most common among wrestlers?', 'sql_query': 'SELECT Reign FROM wrestler GROUP BY Reign ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'wrestler', 'hardness': 'hard', 'cot': '- The SQL query is selecting the "Reign" column from the "wrestler" table.\n- It groups the results by the "Reign" column.\n- It then orders the groups by the count of occurrences in descending order.\n- Finally, it limits the output to only one row, which is the most common reign among wrestlers.'}, {'question': 'Return the name of the wrestler who had the lowest number of days held.', 'sql_query': 'SELECT Name FROM wrestler ORDER BY Days_held ASC LIMIT 1', 'db_id': 'wrestler', 'hardness': 'medium', 'cot': '- The SQL query starts by selecting the "Name" column from the "wrestler" table.\n- The data will be sorted in ascending order based on the "Days_held" column.\n- The "LIMIT 1" clause ensures that only the first row from the sorted data set is returned.\n- Therefore, the query will return the name of the wrestler who had the lowest number of days held.'}], 'race_track': [{'question': 'What is the race class with most number of races.', 'sql_query': 'SELECT CLASS FROM race GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1', 'db_id': 'race_track', 'hardness': 'hard', 'cot': '1. **Group By Class:** The SQL query first groups all the races by their class. This means that all races with the same class will be grouped together.\n\n2. **Count the Number of Races per Class:** Next, the query counts the number of races in each class group using the COUNT(*) function. This gives the total number of races for each class.\n\n3. **Order by Count in Descending Order:** The query then orders the results by the count of races in each class group in descending order. This means that the class with the highest number of races will appear first in the result set.\n\n4. **Limit to 1 Result:** Finally, the query limits the result set to just the first row, effectively returning only the class with the most number of races.'}, {'question': 'What are the different classes of races, and how many races correspond to each?', 'sql_query': 'SELECT CLASS ,  count(*) FROM race GROUP BY CLASS', 'db_id': 'race_track', 'hardness': 'medium', 'cot': '1. The SQL query selects the "Class" column and the count of records for each class from the "race" table.\n2. The GROUP BY clause is used to group the results by the "Class" column, which means that the count will be calculated for each unique class.\n3. By executing this query, we can determine the different classes of races and the number of races that correspond to each class.'}], 'match_season': [{'question': 'Return the names of teams that have no match season record.', 'sql_query': 'SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)', 'db_id': 'match_season', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the `Name` field from the `team` table.\n- It filters the results based on the condition that the `Team_id` is not present in the result set of teams present in the `match_season` table.\n- This subquery `(SELECT Team FROM match_season)` retrieves the list of teams that have match season records.\n- Teams that do not have a match season record will have their `Team_id` not present in this subquery result.\n- Therefore, the main query will return the names of teams that do not have any match season records.'}, {'question': 'How many players played each position?', 'sql_query': 'SELECT POSITION ,  COUNT(*) FROM match_season GROUP BY POSITION', 'db_id': 'match_season', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the `POSITION` column and counting the number of occurrences of each position from the `match_season` table.\n2. The query uses the `GROUP BY` clause to group the results by the `POSITION` column, which means that the count of players for each position will be calculated separately.\n3. By executing this query, we will get a result that shows how many players played each position in the matches recorded in the `match_season` table.'}], 'dorm_1': [{'question': "What are the names of all the dorms that don't have any amenities?", 'sql_query': 'SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)', 'db_id': 'dorm_1', 'hardness': 'hard', 'cot': "1. We want to retrieve the names of all the dorms that don't have any amenities.\n2. To do this, we need to look at the `Dorm` table to get the names of all the dorms.\n3. We also need to check if each dorm has any amenities associated with it, which is stored in the `Has_amenity` table.\n4. The subquery `(SELECT dormid FROM has_amenity)` will give us a list of dorm ids that have amenities.\n5. The main query `SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)` will then select the dorm names from the `Dorm` table where the dormid is not in the list of dorm ids that have amenities.\n6. Executing this query will give us the names of all the dorms that don't have any amenities."}, {'question': 'How many students are from each city, and which cities have more than one cities?', 'sql_query': 'SELECT count(*) ,  city_code FROM student GROUP BY city_code HAVING count(*)  >  1', 'db_id': 'dorm_1', 'hardness': 'medium', 'cot': '1. We start by selecting the count of students (`count(*)`) and the city code (`city_code`) from the `Student` table.\n2. Next, we group the results by the city code using the `GROUP BY` clause. This groups the students based on their city.\n3. Using the `HAVING` clause, we filter the grouped results to only include cities where the count of students in that city is greater than 1 (`count(*) > 1`).\n4. This query will give us the number of students from each city and reveal which cities have more than one student.'}], 'department_management': [{'question': 'In which year were most departments established?', 'sql_query': 'SELECT creation FROM department GROUP BY creation ORDER BY count(*) DESC LIMIT 1', 'db_id': 'department_management', 'hardness': 'hard', 'cot': 'This SQL query is selecting the `creation` column from the `department` table. It is then grouping the results by the `creation` column, ordering them by the count of occurrences in descending order, and limiting the output to only the first result. \n\nTherefore, this query is retrieving the year in which the most departments were established by grouping the departments based on their creation year, counting the number of departments established in each year, and then returning the year with the highest count.'}, {'question': 'Which department has more than 1 head at a time? List the id, name and the number of heads.', 'sql_query': 'SELECT T1.department_id ,  T1.name ,  count(*) FROM management AS T2 JOIN department AS T1 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id HAVING count(*)  >  1', 'db_id': 'department_management', 'hardness': 'medium', 'cot': '1. We are selecting data from the "management" table as T2 and the "department" table as T1.\n2. We are performing an inner join on the "department_id" column between the two tables to get the departments that have more than one head at a time.\n3. We are grouping the result by the "department_id" from table T1.\n4. We are using the HAVING clause to filter out the departments that have a count of heads greater than 1.\n5. The final result will include the department\'s ID, name, and the number of heads that the department has at a given time.'}], 'cre_Doc_Tracking_DB': [{'question': 'Which employees have either destroyed a document or made an authorization to do so? Return their employee ids.', 'sql_query': 'SELECT Destroyed_by_Employee_ID FROM Documents_to_be_destroyed UNION SELECT Destruction_Authorised_by_Employee_ID FROM Documents_to_be_destroyed', 'db_id': 'cre_Doc_Tracking_DB', 'hardness': 'hard', 'cot': "1. The SQL query combines the results from two SELECT statements using the UNION operator.\n2. The first SELECT statement retrieves the 'Destroyed_by_Employee_ID' from the 'Documents_to_be_destroyed' table.\n3. The second SELECT statement retrieves the 'Destruction_Authorised_by_Employee_ID' from the same 'Documents_to_be_destroyed' table.\n4. The UNION operator is used to combine the results of the two SELECT statements into a single result set.\n5. This will give us a list of employee IDs who have either destroyed a document or authorized the destruction of a document."}, {'question': 'Show the name and description of the role played by the employee named Ebba.', 'sql_query': 'SELECT T2.role_name ,  T2.role_description FROM Employees AS T1 JOIN ROLES AS T2 ON T1.role_code  =  T2.role_code WHERE T1.employee_name  =  "Ebba"', 'db_id': 'cre_Doc_Tracking_DB', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the role_name and role_description columns from the tables involved.\n2. The query then specifies the tables involved in the query, which are \'Employees\' table aliased as T1 and \'Roles\' table aliased as T2.\n3. The JOIN keyword is used to combine the two tables based on the condition specified after the ON keyword.\n4. The condition for the join is where the role_code from T1 (Employees table) must match the role_code from T2 (Roles table).\n5. The WHERE clause filters the results where the employee_name from T1 (Employees table) is equal to "Ebba".\n6. This query will then return the name and description of the role played by the employee named Ebba.'}], 'inn_1': [{'question': 'Find the name of rooms whose price is higher than the average price.', 'sql_query': 'SELECT roomName FROM Rooms WHERE basePrice  >  ( SELECT avg(basePrice) FROM Rooms );', 'db_id': 'inn_1', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the column "roomName" from the table "Rooms".\n2. It then applies a filter condition using the WHERE clause to only consider rooms where the "basePrice" is greater than the average price of all rooms.\n3. The subquery inside the parentheses calculates the average of the "basePrice" column from the "Rooms" table.\n4. Finally, the main query retrieves the "roomName" of rooms that meet the condition of having a price higher than the average price.'}, {'question': 'Find the name and id of the top 3 expensive rooms.', 'sql_query': 'SELECT RoomId ,  roomName FROM Rooms ORDER BY basePrice DESC LIMIT 3;', 'db_id': 'inn_1', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the "RoomId" and "roomName" columns from the "Rooms" table.\n2. The data will be retrieved in descending order based on the "basePrice" column.\n3. The ORDER BY clause arranges the data from highest to lowest base price.\n4. The LIMIT 3 clause is used to only return the top 3 results based on the ordering.\n5. Therefore, the query will fetch the RoomId and roomName of the top 3 most expensive rooms in the Rooms table.'}], 'customers_and_addresses': [{'question': 'Find the number of distinct products Rodrick Heaney has bought so far.', 'sql_query': 'SELECT count(DISTINCT t3.product_id) FROM customers AS t1 JOIN customer_orders AS t2 ON t1.customer_id  =  t2.customer_id JOIN order_items AS t3 ON t2.order_id  =  t3.order_id WHERE t1.customer_name  =  "Rodrick Heaney"', 'db_id': 'customers_and_addresses', 'hardness': 'hard', 'cot': 'To find the number of distinct products Rodrick Heaney has bought so far, we first need to identify the customer ID for Rodrick Heaney. We join the `Customers` table with the `Customer_Orders` table on the `customer_id` to link customer data with their orders.\n\nNext, we join the `Customer_Orders` table with the `Order_Items` table on the `order_id` to link the order details with the specific products purchased.\n\nWe filter the data by specifying `WHERE t1.customer_name = "Rodrick Heaney"` to focus only on Rodrick Heaney\'s orders.\n\nFinally, we count the number of distinct products Rodrick Heaney has bought by using `COUNT(DISTINCT t3.product_id)` in the SELECT statement. This count will give us the total number of different products that Rodrick Heaney has purchased.'}, {'question': 'Find the total amount of products ordered before 2018-03-17 07:13:53.', 'sql_query': 'SELECT sum(t2.order_quantity) FROM customer_orders AS t1 JOIN order_items AS t2 ON t1.order_id  =  t2.order_id WHERE t1.order_date  <  "2018-03-17 07:13:53"', 'db_id': 'customers_and_addresses', 'hardness': 'medium', 'cot': 'To find the total amount of products ordered before 2018-03-17 07:13:53, we first need to join the tables `Customer_Orders` and `Order_Items` on their respective `order_id` columns. This will allow us to connect each order with its corresponding order items.\n\nNext, we filter the results based on the condition that the `order_date` from `Customer_Orders` table is less than the specified date "2018-03-17 07:13:53". This condition ensures that we only include orders placed before the specified date.\n\nFinally, we calculate the sum of the `order_quantity` from the `Order_Items` table for all the filtered orders. This gives us the total amount of products ordered before the specified date.'}], 'customers_card_transactions': [{'question': 'Return the type of transaction with the highest total amount.', 'sql_query': 'SELECT transaction_type FROM Financial_transactions GROUP BY transaction_type ORDER BY sum(transaction_amount) DESC LIMIT 1', 'db_id': 'customers_card_transactions', 'hardness': 'hard', 'cot': '1. The SQL query begins by selecting the `transaction_type` from the `Financial_transactions` table.\n2. It then groups the results by `transaction_type` to consolidate rows with the same type.\n3. The query then calculates the total sum of `transaction_amount` for each group of `transaction_type`.\n4. The `ORDER BY` clause is used to sort these aggregated sums in descending order.\n5. Finally, the `LIMIT 1` clause is applied to return only the first row, which corresponds to the `transaction_type` with the highest total amount.'}, {'question': 'What are the different card types, and how many transactions have been made with each?', 'sql_query': 'SELECT T2.card_type_code ,  count(*) FROM Financial_transactions AS T1 JOIN Customers_cards AS T2 ON T1.card_id  =  T2.card_id GROUP BY T2.card_type_code', 'db_id': 'customers_card_transactions', 'hardness': 'medium', 'cot': 'To answer the question "What are the different card types, and how many transactions have been made with each?", the SQL query retrieves the `card_type_code` and the count of transactions made with each card type. \n\n1. The query starts by joining the `Financial_Transactions` table (aliased as T1) with the `Customers_Cards` table (aliased as T2) based on the `card_id` column to link transactions to the respective customer cards.\n   \n2. It then groups the results by the `card_type_code`, which represents the different types of cards held by customers.\n\n3. Finally, the count of transactions associated with each `card_type_code` is calculated to determine how many transactions have been made with each card type.'}], 'cre_Drama_Workshop_Groups': [{'question': 'What is the product ID of the most frequently ordered item on invoices?', 'sql_query': 'SELECT Product_ID FROM INVOICES GROUP BY Product_ID ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'cre_Drama_Workshop_Groups', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `Product_ID` from the `Invoices` table.\n2. It then groups the results by `Product_ID` using the `GROUP BY` clause to aggregate the orders by product.\n3. The `COUNT(*)` function is used to count the occurrences of each `Product_ID` in the grouped results.\n4. The results are then sorted in descending order of the count of each `Product_ID` using `ORDER BY COUNT(*) DESC`.\n5. Finally, the `LIMIT 1` clause is added to only retrieve the first result (which has the highest count), effectively giving us the `Product_ID` of the most frequently ordered item on invoices.'}, {'question': 'Find the phone number and email address of customer "Harold".', 'sql_query': 'SELECT Customer_Phone ,  Customer_Email_Address FROM CUSTOMERS WHERE Customer_Name  =  "Harold"', 'db_id': 'cre_Drama_Workshop_Groups', 'hardness': 'medium', 'cot': 'To find the phone number and email address of the customer named "Harold", we need to use the SQL query that selects the fields "Customer_Phone" and "Customer_Email_Address" from the "Customers" table. We specifically want to retrieve this information for the customer whose name is equal to "Harold". By executing this query, we can filter out the relevant customer details based on the given condition of the customer\'s name being "Harold" and retrieve their phone number and email address.'}], 'baseball_1': [{'question': 'List all the salary values players received in 2010 and 2001.', 'sql_query': 'SELECT salary FROM salary WHERE YEAR  =  2010 UNION SELECT salary FROM salary WHERE YEAR  =  2001', 'db_id': 'baseball_1', 'hardness': 'hard', 'cot': "To retrieve all the salary values players received in 2010 and 2001, the SQL query uses a UNION operator. \n\n- The query first selects the 'salary' column from the 'salary' table where the 'year' column is equal to 2010.\n- Then, it combines the result with the 'salary' values from the same table where the 'year' column is equal to 2001 using the UNION operator.\n\nThis approach allows us to fetch and display all the salary values received by players in the specified years in a single result set."}, {'question': "Compute the average salary of the players in the team called 'Boston Red Stockings'.", 'sql_query': "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'", 'db_id': 'baseball_1', 'hardness': 'medium', 'cot': "- The query first selects the average salary of the players, indicated by selecting the 'avg(T1.salary)'.\n- It then specifies the tables involved by joining the 'salary' table aliased as 'T1' with the 'team' table aliased as 'T2'.\n- The join condition is defined as matching the 'team_id' from the 'salary' table with the 'team_id_br' from the 'team' table, connecting player salaries to their respective teams.\n- The query further restricts the results by specifying the team name condition in the 'WHERE' clause, ensuring only data related to the team 'Boston Red Stockings' is considered.\n- By executing this query, the average salary of the players in the 'Boston Red Stockings' team will be computed and returned as the result."}], 'cre_Theme_park': [{'question': 'Find the names of the tourist attractions that is either accessible by walk or at address 660 Shea Crescent.', 'sql_query': 'SELECT T2.Name FROM Locations AS T1 JOIN Tourist_Attractions AS T2 ON T1.Location_ID  =  T2.Location_ID WHERE T1.Address  =  "660 Shea Crescent" OR T2.How_to_Get_There  =  "walk"', 'db_id': 'cre_Theme_park', 'hardness': 'hard', 'cot': 'To find the names of tourist attractions that are either accessible by walk or are located at address 660 Shea Crescent, we need to first join the Locations table (aliased as T1) with the Tourist_Attractions table (aliased as T2) using the Location_ID as the joining condition.\n\nNext, we filter the result by checking if the address in the Locations table is "660 Shea Crescent" OR if the description of how to get to the attraction in the Tourist_Attractions table is "walk".\n\nFinally, we select the Name column from the Tourist_Attractions table T2 to retrieve the names of the tourist attractions that meet the specified conditions.'}, {'question': 'What are the names and descriptions of the photos taken at the tourist attraction "film festival"?', 'sql_query': 'SELECT T1.Name ,  T1.Description FROM PHOTOS AS T1 JOIN TOURIST_ATTRACTIONS AS T2 ON T1.Tourist_Attraction_ID  =  T2.Tourist_Attraction_ID WHERE T2.Name  =  "film festival"', 'db_id': 'cre_Theme_park', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the columns `Name` and `Description` from the tables `Photos (aliased as T1)` and `Tourist_Attractions (aliased as T2)`.\n2. The query is performing an inner join between the `Photos` table and the `Tourist_Attractions` table using the condition `T1.Tourist_Attraction_ID = T2.Tourist_Attraction_ID`.\n3. The join is based on relating the photos to tourist attractions.\n4. The SELECT statement is filtering the results using the condition `WHERE T2.Name = "film festival"`.\n5. This condition filters the tourist attractions to only include the one with the name "film festival".\n6. By joining and filtering the data in this way, the query retrieves the names and descriptions of the photos taken at the tourist attraction labeled as "film festival".'}], 'cinema': [{'question': 'Show all the locations where no cinema has capacity over 800.', 'sql_query': 'SELECT LOCATION FROM cinema EXCEPT SELECT LOCATION FROM cinema WHERE capacity  >  800', 'db_id': 'cinema', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the "LOCATION" from the "cinema" table.\n2. Next, it uses the EXCEPT operator to get the locations that will be returned by the first SELECT statement minus the locations that will be returned by the second SELECT statement.\n3. The second SELECT statement selects "LOCATION" from the "cinema" table but with a condition that filters out cinemas with a capacity greater than 800.\n4. Therefore, the query will return the locations where no cinema has a capacity over 800.'}, {'question': 'Show all the locations with at least two cinemas with capacity above 300.', 'sql_query': 'SELECT LOCATION FROM cinema WHERE capacity  >  300 GROUP BY LOCATION HAVING count(*)  >=  2', 'db_id': 'cinema', 'hardness': 'medium', 'cot': '1. The SQL query begins by selecting the column "LOCATION" from the "cinema" table.\n2. The query then filters the results by the condition "capacity > 300", which means only cinemas with a capacity above 300 will be considered.\n3. The SELECT statement is followed by the GROUP BY clause, which groups the selected locations together.\n4. The query then uses the HAVING clause to filter the grouped results. The condition specified in the HAVING clause is "count(*) >= 2", which means that only locations with at least two cinemas meeting the capacity criteria will be included in the final result.\n5. As a result, the output will display the locations where there are at least two cinemas with a capacity above 300.'}], 'apartment_rentals': [{'question': 'Show the apartment type code that has the largest number of total rooms, together with the number of bathrooms and number of bedrooms.', 'sql_query': 'SELECT apt_type_code ,  bathroom_count ,  bedroom_count FROM Apartments GROUP BY apt_type_code ORDER BY sum(room_count) DESC LIMIT 1', 'db_id': 'apartment_rentals', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the columns `apt_type_code`, `bathroom_count`, and `bedroom_count` from the table `Apartments`.\n- It then groups the result by `apt_type_code` using the `GROUP BY` clause.\n- Next, it calculates the total number of rooms for each `apt_type_code` by summing the `room_count` values.\n- The results are then ordered in descending order based on the total sum of `room_count` for each `apt_type_code`.\n- Finally, it limits the output to only the first row, which will represent the apartment type with the largest number of total rooms, along with the corresponding number of bathrooms and bedrooms.'}, {'question': 'Show the total number of rooms of all apartments with facility code "Gym".', 'sql_query': 'SELECT sum(T2.room_count) FROM Apartment_Facilities AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.facility_code  =  "Gym"', 'db_id': 'apartment_rentals', 'hardness': 'medium', 'cot': 'To calculate the total number of rooms of all apartments with the facility code "Gym", we need to follow these steps:\n1. Use the `Apartment_Facilities` table (aliased as T1) to filter only the rows where the facility code is "Gym".\n2. Join the `Apartment_Facilities` table with the `Apartments` table (aliased as T2) based on the `apt_id` to get the corresponding apartment details.\n3. Select the `room_count` from the `Apartments` table for all apartments that have the facility code "Gym".\n4. Sum up all the `room_count` values to get the total number of rooms in apartments with the facility code "Gym". \n5. Output the result as the total number of rooms.'}], 'station_weather': [{'question': 'Find names and times of trains that run through stations for the local authority Chiltern.', 'sql_query': 'SELECT t3.name ,  t3.time FROM station AS t1 JOIN route AS t2 ON t1.id  =  t2.station_id JOIN train AS t3 ON t2.train_id  =  t3.id WHERE t1.local_authority  =  "Chiltern"', 'db_id': 'station_weather', 'hardness': 'hard', 'cot': '- We are selecting the names and times of trains that run through stations for the local authority "Chiltern".\n- We start by joining the `station` table as `t1` with the `route` table as `t2` on the condition that the station IDs match.\n- Then, we join the `train` table as `t3` based on the train IDs from the `route` table to get the train\'s name and time information.\n- Finally, we filter the results by only considering the rows where the local_authority from the `station` table is "Chiltern". This gives us the trains that run through stations in the Chiltern local authority.'}, {'question': "How many trains have 'Express' in their names?", 'sql_query': 'SELECT count(*) FROM train WHERE name LIKE "%Express%"', 'db_id': 'station_weather', 'hardness': 'medium', 'cot': 'This SQL query is counting the number of trains that have the word \'Express\' in their names. \n1. The query is selecting the count of all rows from the \'train\' table.\n2. It is filtering the rows based on the \'name\' column using the LIKE operator with the pattern "%Express%", which matches any occurrence of \'Express\' in the train names.\n3. The COUNT(*) function is then used to count the number of rows that satisfy the condition.\n4. The result of this query will be the total count of trains with \'Express\' in their names.'}], 'local_govt_in_alabama': [{'question': "Which events id does not have any participant with detail 'Kenyatta Kuhn'?", 'sql_query': "SELECT event_id FROM EVENTS EXCEPT SELECT T1.event_id FROM Participants_in_Events AS T1 JOIN Participants AS T2 ON T1.Participant_ID  =  T2.Participant_ID WHERE Participant_Details  =  'Kenyatta Kuhn'", 'db_id': 'local_govt_in_alabama', 'hardness': 'hard', 'cot': "1. The SQL query starts with selecting the `event_id` from the `Events` table.\n   \n2. It then uses the EXCEPT keyword which is used to return all rows from the first result set that are not found in the second result set. \n   \n3. In the second part of the query, it selects `event_id` from the table `Participants_in_Events` (aliased as T1) and joins it with the `Participants` table (aliased as T2) on the `Participant_ID` to get the `event_id` that has a participant with the detail 'Kenyatta Kuhn'.\n   \n4. The WHERE clause filters the rows to only include those where the `Participant_Details` is 'Kenyatta Kuhn'.\n   \n5. By using the EXCEPT keyword, the query then returns the `event_id`s from the first SELECT statement that are not present in the second SELECT statement, which means it returns the `event_id`s that do not have any participant with the detail 'Kenyatta Kuhn'."}, {'question': 'What are the ids and details of events that have more than one participants?', 'sql_query': 'SELECT T1.event_id ,  T1.event_details FROM EVENTS AS T1 JOIN Participants_in_Events AS T2 ON T1.Event_ID  =  T2.Event_ID GROUP BY T1.Event_ID HAVING count(*)  >  1', 'db_id': 'local_govt_in_alabama', 'hardness': 'medium', 'cot': '1. The query starts by selecting the `event_id` and `event_details` from the `Events` table (aliased as T1) and the `Participants_in_Events` table (aliased as T2).\n2. It then performs an inner join between the `Events` and `Participants_in_Events` tables based on the `Event_ID` to link events with their participants.\n3. The query then groups the results by `Event_ID` from the T1 table (Events) using `GROUP BY T1.Event_ID`.\n4. Finally, it filters the grouped results by the number of participants per event using the `HAVING` clause with the condition `count(*) > 1`, ensuring that only events with more than one participant are selected.\n5. The final result will provide the `event_id` and `event_details` of events that have more than one participant.'}], 'game_1': [{'question': "Show all male student ids who don't play football.", 'sql_query': 'SELECT StuID FROM Student WHERE sex  =  \'M\' EXCEPT SELECT StuID FROM Sportsinfo WHERE sportname  =  "Football"', 'db_id': 'game_1', 'hardness': 'hard', 'cot': "1. The SQL query begins by selecting the StuID from the Student table where the sex column value is 'M', indicating male students.\n2. The query then uses the EXCEPT keyword to subtract the StuIDs of students who play football from the previously selected male student IDs. \n3. By using the EXCEPT operator, the query effectively filters out the StuIDs of male students who also play football from the final result set.\n4. Therefore, the output of this query will be the StuIDs of male students who do not play football."}, {'question': 'Show all video games and their types in the order of their names.', 'sql_query': 'SELECT gname ,  gtype FROM Video_games ORDER BY gname', 'db_id': 'game_1', 'hardness': 'medium', 'cot': '1. The SQL query starts with the `SELECT` keyword, indicating that we want to retrieve specific columns from a table.\n\n2. The columns specified after the `SELECT` keyword are `gname` and `gtype`, indicating that we want to retrieve these columns from the `Video_Games` table.\n\n3. The `FROM` keyword is used to specify the table from which to retrieve the data, in this case, `Video_Games`.\n\n4. The `ORDER BY` keyword is used to sort the results based on a specific column, in this case, `gname`.\n\n5. Therefore, the query will fetch all the rows from the `Video_Games` table, selecting only the `gname` and `gtype` columns, and then order these results by the `gname` column in ascending order.'}], 'employee_hire_evaluation': [{'question': 'Which shops run with no employees? Find the shop names', 'sql_query': 'SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring)', 'db_id': 'employee_hire_evaluation', 'hardness': 'hard', 'cot': '1. The SQL query is selecting the "name" column from the "shop" table.\n2. It is using a subquery to find the shop_ids that are not present in the "hiring" table (which means these are the shops with no employees).\n3. The main query then retrieves the names of shops that do not have any entries in the "hiring" table, meaning they run with no employees.\n4. Finally, the query will return the names of the shops that run with no employees.'}, {'question': 'What is the number of employees from each city?', 'sql_query': 'SELECT count(*) ,  city FROM employee GROUP BY city', 'db_id': 'employee_hire_evaluation', 'hardness': 'medium', 'cot': '1. The query starts by selecting the count of records (* represents all records) and the city column from the employee table.\n2. It then groups the results based on the city column using the GROUP BY clause.\n3. For each unique city in the employee table, the query will count the number of employees belonging to that city.\n4. The query will return a result set showing the number of employees from each city.'}], 'train_station': [{'question': "Show all locations which don't have a train station with at least 15 platforms.", 'sql_query': 'SELECT LOCATION FROM station EXCEPT SELECT LOCATION FROM station WHERE number_of_platforms  >=  15', 'db_id': 'train_station', 'hardness': 'hard', 'cot': 'We start by querying the "station" table to select all unique locations. Then, we use the EXCEPT keyword to subtract the locations where the number of platforms is greater than or equal to 15. This will give us the locations which don\'t have a train station with at least 15 platforms.'}, {'question': 'Show all locations that have train stations with at least 15 platforms and train stations with more than 25 total passengers.', 'sql_query': 'SELECT DISTINCT LOCATION FROM station WHERE number_of_platforms  >=  15 AND total_passengers  >  25', 'db_id': 'train_station', 'hardness': 'medium', 'cot': '1. The SQL query is selecting distinct locations from the "station" table.\n2. It filters the results based on two conditions:\n   a. The number of platforms at the station is greater than or equal to 15.\n   b. The total number of passengers at the station is more than 25.\n3. The query uses the logical AND operator to combine these two conditions.\n4. The results will only show locations that have train stations meeting both criteria simultaneously.'}], 'musical': [{'question': 'Return the most frequent result across all musicals.', 'sql_query': 'SELECT RESULT FROM musical GROUP BY RESULT ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'musical', 'hardness': 'hard', 'cot': '- The SQL query selects the "RESULT" column from the "musical" table.\n- It then groups the selected results by the "RESULT" column to aggregate the rows with the same result.\n- It orders the groups by the count of rows in each group in descending order to identify the most frequent result.\n- Finally, it limits the output to only 1 row, which corresponds to the most frequent result across all musicals.'}, {'question': 'Show names of actors that have appeared in musical with name "The Phantom of the Opera".', 'sql_query': 'SELECT T1.Name FROM actor AS T1 JOIN musical AS T2 ON T1.Musical_ID  =  T2.Musical_ID WHERE T2.Name  =  "The Phantom of the Opera"', 'db_id': 'musical', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the "Name" column from the "actor" table, aliasing it as T1.\n2. It then performs an inner join between the "actor" table (aliased as T1) and the "musical" table (aliased as T2) based on the condition that T1.Musical_ID is equal to T2.Musical_ID.\n3. The query then filters the results based on the condition that the "Name" in the "musical" table (T2.Name) is equal to "The Phantom of the Opera".\n4. Finally, the query retrieves and displays the "Name" of the actors who have appeared in the musical with the name "The Phantom of the Opera".'}], 'flight_2': [{'question': 'Find the name of airports which do not have any flight in and out.', 'sql_query': 'SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights)', 'db_id': 'flight_2', 'hardness': 'hard', 'cot': '- We want to find the name of airports which do not have any flight in and out.\n- To do this, we first need to select the AirportCodes that are not present in either the SourceAirport or DestAirport columns of the Flights table.\n- We can achieve this by using a subquery to select SourceAirport from Flights table and another subquery to select DestAirport from Flights table, then combine the results using UNION to get a single list of all airports involved in flights.\n- Next, we can use the NOT IN operator to select AirportCodes in the Airports table that are not present in the list of airports involved in flights.\n- Finally, we select the AirportName of these airports to get the desired result.'}, {'question': 'Find all airlines that have fewer than 200 flights.', 'sql_query': 'SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200', 'db_id': 'flight_2', 'hardness': 'medium', 'cot': "- We are selecting data from the 'airlines' table as T1 and the 'flights' table as T2 in this query.\n- We are performing an inner join between the 'airlines' and 'flights' tables on the 'uid' column from T1 (airlines) and the 'Airline' column from T2 (flights).\n- We are grouping the result set by the 'Airline' column from T1 (airlines) using the GROUP BY clause.\n- Then, we are filtering the results using the HAVING clause with the condition count(*) < 200, which means we only want to include airlines that have fewer than 200 flights in the result set.\n- This query will return all airlines that have fewer than 200 flights."}], 'e_learning': [{'question': 'Find the common personal name of course authors and students.', 'sql_query': 'SELECT personal_name FROM Course_Authors_and_Tutors INTERSECT SELECT personal_name FROM Students', 'db_id': 'e_learning', 'hardness': 'hard', 'cot': '- The SQL query first selects the `personal_name` column from the table `Course_Authors_and_Tutors`.\n- Then, it performs an intersection operation (`INTERSECT` keyword) with the result of selecting the `personal_name` column from the `Students` table.\n- This intersection operation will return only the common `personal_name` values that exist in both tables `Course_Authors_and_Tutors` and `Students`.\n- The final result will be the set of `personal_name` values that are shared between course authors and students.'}, {'question': 'Return the descriptions and names of the courses that have more than two students enrolled in.', 'sql_query': 'SELECT T1.course_description ,  T1.course_name FROM Courses AS T1 JOIN Student_Course_Enrolment AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name HAVING COUNT(*)  >  2', 'db_id': 'e_learning', 'hardness': 'medium', 'cot': '1. The SQL query selects the `course_description` and `course_name` columns from the `Courses` table aliased as `T1`.\n2. It then joins the `Courses` table with the `Student_Course_Enrolment` table aliased as `T2` using the `course_id` column.\n3. The `GROUP BY` clause is used to group the result set by the `course_name`.\n4. The `HAVING` clause filters out the grouped results, only including those where the `COUNT(*)` (number of students enrolled) is greater than 2.'}], 'behavior_monitoring': [{'question': 'What is the cell phone number of the student whose address has the lowest monthly rental?', 'sql_query': 'SELECT T2.cell_mobile_number FROM Student_Addresses AS T1 JOIN Students AS T2 ON T1.student_id  =  T2.student_id ORDER BY T1.monthly_rental ASC LIMIT 1', 'db_id': 'behavior_monitoring', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the cell phone number (`cell_mobile_number`) from the `Students` table aliasing it as `T2`.\n2. It then performs a join operation between the `Student_Addresses` table aliasing it as `T1` and the `Students` table aliasing it as `T2` using the condition `T1.student_id = T2.student_id`.\n3. The records are sorted in ascending order of the monthly rental (`monthly_rental`) from the `Student_Addresses` table using the `ORDER BY T1.monthly_rental ASC`.\n4. Finally, the query limits the result to the first row using `LIMIT 1`, ensuring that only the student with the lowest monthly rental is selected.\n5. Therefore, the query retrieves the cell phone number of the student whose address has the lowest monthly rental.'}, {'question': 'What are the line 1 and average monthly rentals of all student addresses?', 'sql_query': 'SELECT T1.line_1 ,  avg(T2.monthly_rental) FROM Addresses AS T1 JOIN Student_Addresses AS T2 ON T1.address_id  =  T2.address_id GROUP BY T2.address_id', 'db_id': 'behavior_monitoring', 'hardness': 'medium', 'cot': '1. The SQL query selects the `line_1` column from the `Addresses` table (aliased as T1) and calculates the average of the `monthly_rental` column from the `Student_Addresses` table (aliased as T2).\n2. The query performs an inner join between the `Addresses` table and the `Student_Addresses` table using the `address_id` column as the joining condition (`T1.address_id = T2.address_id`).\n3. The result is grouped by `address_id` from the `Student_Addresses` table to calculate the average monthly rental for each unique student address.\n4. The query retrieves the `line_1` values of the addresses and the corresponding average monthly rental for each address.'}], 'flight_1': [{'question': 'What are the names of all employees who have a salary higher than average?', 'sql_query': 'SELECT name FROM Employee WHERE salary  >  (SELECT avg(salary) FROM Employee)', 'db_id': 'flight_1', 'hardness': 'hard', 'cot': "1. Subquery: Calculate the average salary of all employees in the employee table.\n2. Main Query: Retrieve the names of employees from the employee table where their salary is higher than the average salary calculated in the subquery. \n3. The query compares each employee's salary with the average salary obtained from the subquery and returns only the names of employees who have a salary higher than the calculated average salary."}, {'question': 'Show flight number, origin, destination of all flights in the alphabetical order of the departure cities.', 'sql_query': 'SELECT flno ,  origin ,  destination FROM Flight ORDER BY origin', 'db_id': 'flight_1', 'hardness': 'medium', 'cot': '1. Start by selecting the columns `flno`, `origin`, and `destination` from the `Flight` table.\n2. Use the `ORDER BY` clause to sort the results in alphabetical order based on the `origin` column.\n3. This query will retrieve the flight number, origin, and destination of all flights, sorted in ascending order based on the departure cities.'}], 'orchestra': [{'question': 'What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?', 'sql_query': 'SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003', 'db_id': 'orchestra', 'hardness': 'hard', 'cot': '1. The SQL query begins by selecting the record companies from the "orchestra" table where the year of founding is before 2003. \n2. Next, it selects the record companies from the same table where the year of founding is after 2003.\n3. By using the INTERSECT operator, the query finds the common record companies that are used by orchestras founded before 2003 and those founded after 2003. \n4. The output will be the list of record companies that meet this condition.'}, {'question': 'Please show the record formats of orchestras in ascending order of count.', 'sql_query': 'SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC', 'db_id': 'orchestra', 'hardness': 'medium', 'cot': '1. The SQL query is using the SELECT statement to retrieve the column Major_Record_Format from the table orchestra.\n2. The GROUP BY clause is used to group the records based on the Major_Record_Format column.\n3. The ORDER BY clause is sorting the groups in ascending order of the COUNT(*) function, which counts the number of occurrences of each Major_Record_Format.\n4. This query will display the record formats of orchestras in ascending order based on the count of each record format.'}], 'hospital_1': [{'question': 'What is the employee id of the head whose department has the least number of employees?', 'sql_query': 'SELECT head FROM department GROUP BY departmentID ORDER BY count(departmentID) LIMIT 1;', 'db_id': 'hospital_1', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `head` column from the `Department` table.\n2. It then groups the results by `departmentID` using the `GROUP BY` clause.\n3. Next, it counts the number of occurrences of `departmentID` for each group using the `count(departmentID)` function.\n4. The results are then ordered in ascending order based on the count of `departmentID` groups using `ORDER BY count(departmentID)`.\n5. Finally, it limits the output to only the first row using `LIMIT 1`, which gives us the head of the department with the least number of employees.'}, {'question': 'What is the id of the appointment that started most recently?', 'sql_query': 'SELECT appointmentid FROM appointment ORDER BY START DESC LIMIT 1', 'db_id': 'hospital_1', 'hardness': 'medium', 'cot': '1. **SELECT statement**: The query starts by selecting the `appointmentid` from the `appointment` table. The `appointmentid` is the unique identifier for each appointment record.\n\n2. **ORDER BY clause**: Next, the query orders the results based on the `START` column in descending order. This means that the appointments will be arranged with the most recent ones first.\n\n3. **LIMIT clause**: Finally, the query uses the `LIMIT 1` clause to restrict the output to only the first row. This ensures that we only get the `appointmentid` of the most recent appointment that started.'}], 'gas_company': [{'question': "What are the headquarters that have both a company in the banking and 'oil and gas' industries?", 'sql_query': "SELECT headquarters FROM company WHERE main_industry  =  'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry  =  'Oil and gas'", 'db_id': 'gas_company', 'hardness': 'hard', 'cot': "1. The SQL query first selects the headquarters of companies where the main industry is 'Banking'.\n2. The SQL query then selects the headquarters of companies where the main industry is 'Oil and gas'.\n3. The INTERSECT operator is used to combine the results of the two SELECT statements to return only the headquarters that appear in both sets of results.\n4. This way, the query will retrieve the headquarters that have companies in both the banking and 'oil and gas' industries."}, {'question': 'What is the name and rank of every company ordered by descending number of sales?', 'sql_query': 'SELECT company ,  rank FROM company ORDER BY Sales_billion DESC', 'db_id': 'gas_company', 'hardness': 'medium', 'cot': '- We start by selecting the columns "company" and "rank" from the table "company".\n- Then, we sort the results in descending order based on the column "Sales_billion".\n- This query will return the name and rank of every company, ordered by the descending number of sales.'}], 'game_injury': [{'question': 'Show all headquarters with both a company in banking industry and a company in Oil and gas.', 'sql_query': "SELECT headquarters FROM company WHERE main_industry  =  'Banking' INTERSECT SELECT headquarters FROM company WHERE main_industry  =  'Oil and gas'", 'db_id': 'gas_company', 'hardness': 'hard', 'cot': '1. The SQL query involves selecting the headquarters of companies from the "company" table.\n2. The query uses the INTERSECT operator to combine the results of two SELECT statements that retrieve headquarters of companies in the banking industry and the oil and gas industry separately.\n3. The first SELECT statement filters the companies based on their main industry being \'Banking\'.\n4. The second SELECT statement filters the companies based on their main industry being \'Oil and gas\'.\n5. By using the INTERSECT operator, the query will return only the headquarters that appear in both result sets, effectively finding the headquarters that have both a company in the banking industry and a company in the oil and gas industry.'}, {'question': 'What are the ids, scores, and dates of the games which caused at least two injury accidents?', 'sql_query': 'SELECT T1.id ,  T1.score ,  T1.date FROM game AS T1 JOIN injury_accident AS T2 ON T2.game_id  =  T1.id GROUP BY T1.id HAVING count(*)  >=  2', 'db_id': 'game_injury', 'hardness': 'medium', 'cot': '- The SQL query starts by selecting the columns `id`, `score`, and `date` from the `game` table, aliased as `T1`.\n\n- It then performs an inner join with the `injury_accident` table, aliased as `T2`, on the condition that the `game_id` in `injury_accident` matches the `id` in `game`.\n\n- The `GROUP BY T1.id` clause groups the result set by the `id` of the game.\n\n- Finally, the `HAVING count(*) >= 2` clause filters the grouped results to only include those games where the count of injury accidents associated with that game is two or more.\n\n- Therefore, the final result will show the `id`, `score`, and `date` of the games that had at least two injury accidents associated with them.'}], 'hr_1': [{'question': 'Find the ids of the employees who does not work in those departments where some employees works whose manager id within the range 100 and 200.', 'sql_query': 'SELECT * FROM employees WHERE department_id NOT IN (SELECT department_id FROM departments WHERE manager_id BETWEEN 100 AND 200)', 'db_id': 'hr_1', 'hardness': 'hard', 'cot': "1. The SQL query retrieves all columns from the 'employees' table.\n2. The subquery within the WHERE clause fetches the department_ids from the 'departments' table where the manager_id falls between 100 and 200.\n3. The main query filters the employees based on their department_id not being present in the result set obtained from the subquery.\n4. This query essentially finds employees who are not working in departments where the manager's id is within the range of 100 to 200."}, {'question': 'Return all information about employees with salaries between 8000 and 12000 for which commission is not null or where their department id is not 40.', 'sql_query': 'SELECT * FROM employees WHERE salary BETWEEN 8000 AND 12000 AND commission_pct != "null" OR  department_id != 40', 'db_id': 'hr_1', 'hardness': 'medium', 'cot': '1. **Retrieve data:** The SQL query starts by requesting information from the `employees` table.\n2. **Conditions:** The query specifies two conditions using the `WHERE` clause:\n   - *Salary range:* It selects employees whose salary is between 8000 and 12000.\n   - *Commission not null or department ID not 40:* The query adds a logical OR condition. It fetches records where the commission percentage is not explicitly set as "null" or the department ID is not equal to 40.\n3. **Execution:** Upon execution, the SQL engine will return all the relevant employee details based on the specified conditions for analysis or reporting.'}], 'performance_attendance': [{'question': 'Show the most common location of performances.', 'sql_query': 'SELECT LOCATION FROM performance GROUP BY LOCATION ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'performance_attendance', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the `LOCATION` column from the `performance` table.\n- It then groups the selected locations using the `GROUP BY` clause to create unique groups based on the location.\n- The `ORDER BY COUNT(*) DESC` part is used to order these groups based on the count of performances that took place at each location in descending order.\n- Finally, `LIMIT 1` is used to limit the results to only one row, which will give us the most common location of performances.'}, {'question': 'What are the dates and locations of performances?', 'sql_query': 'SELECT Date ,  LOCATION FROM performance', 'db_id': 'performance_attendance', 'hardness': 'medium', 'cot': 'This SQL query is selecting the `Date` and `Location` columns from the `performance` table. It is asking for information about the dates and locations of performances stored in the database. By using the `SELECT` statement with specific column names, the query aims to retrieve only the required data without unnecessary information. This query does not specify any conditions or filters, so it will return all rows from the `performance` table with the `Date` and `Location` columns, providing a comprehensive list of all performance dates and locations.'}], 'body_builder': [{'question': 'What is the most common birth place of people?', 'sql_query': 'SELECT Birth_Place FROM people GROUP BY Birth_Place ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'body_builder', 'hardness': 'hard', 'cot': '1. Start by selecting the column "Birth_Place" from the "people" table.\n2. Group the results by "Birth_Place" to get distinct birth places.\n3. Order the groups by the count of occurrences in descending order using "COUNT(*) DESC".\n4. Limit the output to only the first result using "LIMIT 1".\n5. This will give us the most common birth place of people based on the count of occurrences in the database.'}, {'question': 'What are the names of body builders whose total score is higher than 300?', 'sql_query': 'SELECT T2.Name FROM body_builder AS T1 JOIN people AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Total  >  300', 'db_id': 'body_builder', 'hardness': 'medium', 'cot': '- We want to fetch the names of body builders whose total score is higher than 300. \n- To do this, we need to join the "body_builder" table with the "people" table using the "People_ID" column as the foreign key.\n- We will select the "Name" column from the "people" table as the output.\n- The condition for filtering is that the "Total" score in the "body_builder" table should be greater than 300. \n- Therefore, the query joins the two tables on the "People_ID" column and filters the result based on the total score condition.'}], 'student_assessment': [{'question': 'What is detail of the student who most recently registered course?', 'sql_query': 'SELECT T2.student_details FROM student_course_registrations AS T1 JOIN students AS T2 ON T1.student_id = T2.student_id ORDER BY T1.registration_date DESC LIMIT 1', 'db_id': 'student_assessment', 'hardness': 'hard', 'cot': 'To find the details of the student who most recently registered for a course, we can use a JOIN between the `student_course_registrations` table (aliased as T1) and the `students` table (aliased as T2) on the student_id column. By ordering the result set in descending order based on the registration date and limiting the output to 1 row, we can obtain the details of the student who most recently registered for a course.'}, {'question': 'How many courses do the student whose id is 171 attend?', 'sql_query': 'SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171', 'db_id': 'student_assessment', 'hardness': 'medium', 'cot': 'To answer the question "How many courses do the student whose id is 171 attend?", we need to:\n\n1. Join the `Courses` table (aliased as T1) with the `Student_Course_Attendance` table (aliased as T2) on the `course_id`.\n2. Specify the condition to filter the rows where the `student_id` is 171.\n3. Count the number of rows returned after the join and filtering to determine the number of courses the student with id 171 attends.'}], 'company_office': [{'question': 'List the industry shared by the most companies.', 'sql_query': 'SELECT Industry FROM Companies GROUP BY Industry ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'company_office', 'hardness': 'hard', 'cot': '1. We start by selecting the "Industry" column from the "Companies" table.\n2. We then group the results by the "Industry" column. This groups all the rows that have the same industry together.\n3. Next, we count the occurrences of each industry using COUNT(*), which counts the number of rows in each group.\n4. We then order the groups by the count of companies in each industry in descending order using ORDER BY COUNT(*) DESC.\n5. Finally, we limit the result set to only the first row using LIMIT 1, which gives us the industry shared by the most companies.'}, {'question': 'Find the number of companies whose industry is "Banking" or "Conglomerate",', 'sql_query': 'SELECT count(*) FROM Companies WHERE Industry  =  "Banking" OR Industry  =  "Conglomerate"', 'db_id': 'company_office', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the count of records from the "Companies" table.\n2. It specifies a condition using the WHERE clause to filter the records where the Industry is either "Banking" or "Conglomerate".\n3. The OR operator is used to include companies with either of these two industries in the result set.\n4. The count function is applied to get the total number of companies that satisfy the specified condition.\n5. Finally, the query will return the count of companies whose industry is either "Banking" or "Conglomerate".'}], 'network_2': [{'question': 'What are the different names and ages of every friend of either Dan or alice?', 'sql_query': "SELECT DISTINCT T1.name ,  T1.age FROM Person AS T1 JOIN PersonFriend AS T2 ON T1.name  =  T2.name WHERE T2.friend  =  'Dan' OR T2.friend  =  'Alice'", 'db_id': 'network_2', 'hardness': 'hard', 'cot': "1. The SQL query starts by selecting distinct values of names and ages from the Person table, aliased as T1.\n2. The query then joins the Person table with the PersonFriend table, aliased as T2, using the condition where the name in T1 is equal to the name in T2.\n3. It further filters the results by selecting only the rows where the friend in T2 is either 'Dan' or 'Alice'.\n4. The query retrieves the names and ages of all the friends of either 'Dan' or 'Alice'."}, {'question': 'How old is the average person for each job?', 'sql_query': 'SELECT avg(age) ,  job FROM Person GROUP BY job', 'db_id': 'network_2', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the average age and job from the Person table.\n2. It is using the GROUP BY clause to group the data by the job column.\n3. This means that the query will calculate the average age for each distinct job in the Person table.\n4. The result will show the average age of people for each job category.'}], 'ship_mission': [{'question': 'What is the most common type of ships?', 'sql_query': 'SELECT TYPE FROM ship GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'ship_mission', 'hardness': 'hard', 'cot': '1. The SQL query retrieves the "Type" column from the "ship" table.\n2. It groups the results by the "Type" column.\n3. It then calculates the count of each unique type of ship.\n4. The results are then ordered by the count of each type in descending order, meaning the most common type will appear first.\n5. Finally, the query limits the output to only the first row (LIMIT 1), which will give us the most common type of ships.'}, {'question': 'What is the name of the ship with the largest tonnage?', 'sql_query': 'SELECT Name FROM ship ORDER BY Tonnage DESC LIMIT 1', 'db_id': 'ship_mission', 'hardness': 'medium', 'cot': 'This SQL query is selecting the "Name" column from the "ship" table. It is sorting the results in descending order based on the "Tonnage" column. By using the "LIMIT 1" clause, it will only return the row with the highest tonnage, which corresponds to the ship with the largest tonnage. Therefore, the query will provide the name of the ship with the largest tonnage.'}], 'allergy_1': [{'question': 'What is the last name of the youngest student?', 'sql_query': 'SELECT LName FROM Student WHERE age  =  (SELECT min(age) FROM Student)', 'db_id': 'allergy_1', 'hardness': 'hard', 'cot': 'The SQL query starts by selecting the minimum age from the Student table using the subquery (SELECT min(age) FROM Student). Then, it retrieves the last name (LName) of the student(s) with the age equal to the minimum age found in the subquery. This will give us the last name of the youngest student in the database.'}, {'question': 'How many students are affected by each allergy type?', 'sql_query': 'SELECT T2.allergytype ,  count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy GROUP BY T2.allergytype', 'db_id': 'allergy_1', 'hardness': 'medium', 'cot': '1. The SQL query is selecting data from the tables `Has_allergy` and `Allergy_type` by joining them together on the column `allergy` to match the allergy types between the two tables.\n\n2. It then groups the results by the `allergytype` from the `Allergy_type` table.\n\n3. The `count(*)` function is used to count the number of rows for each distinct `allergytype`, which gives the number of students affected by each allergy type.\n\n4. By grouping the results in this way, the query provides a breakdown of the number of students affected by each type of allergy.'}], 'party_people': [{'question': 'Which member names are shared among members in the party with the id 3 and the party with the id 1?', 'sql_query': 'SELECT member_name FROM member WHERE party_id  =  3 INTERSECT SELECT member_name FROM member WHERE party_id  =  1', 'db_id': 'party_people', 'hardness': 'hard', 'cot': '1. The SQL query starts by retrieving the member names from the "member" table where the party_id is equal to 3.\n2. Then, it uses the INTERSECT operator to combine this result with another query that retrieves the member names from the same table where the party_id is equal to 1.\n3. The INTERSECT operator returns only the rows that appear in both results sets, effectively giving us the member names that are shared among members in the party with party_id 3 and party_id 1.'}, {'question': 'Show all ministers and parties they belong to in descending order of the time they took office.', 'sql_query': 'SELECT minister ,  party_name FROM party ORDER BY took_office DESC', 'db_id': 'party_people', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the columns "minister" and "party_name" from the "party" table.\n2. The results will be ordered in descending order based on the column "took_office", which represents the time the minister took office.\n3. This will display all ministers and the parties they belong to, with the ministers who took office more recently appearing first in the result set.\n4. The query does not require any filtering or joining with other tables as the necessary information is already available in the "party" table.'}], 'csu_1': [{'question': 'For each Orange county campus, report the number of degrees granted after 2000.', 'sql_query': 'SELECT T1.campus ,  sum(T2.degrees) FROM campuses AS T1 JOIN degrees AS T2 ON T1.id  =  T2.campus WHERE T1.county  =  "Orange" AND T2.year  >=  2000 GROUP BY T1.campus', 'db_id': 'csu_1', 'hardness': 'hard', 'cot': "1. Start by selecting the columns we want in the output - campus and the sum of degrees.\n2. We need to get this information from two tables - campuses and degrees.\n3. Join the campuses table as T1 and degrees table as T2 using the common column 'id' from campuses and 'campus' from degrees.\n4. Apply a condition to only consider campuses located in Orange county by checking the 'county' column from campuses table.\n5. Apply another condition to only consider degrees granted after the year 2000 by checking the 'year' column from the degrees table.\n6. Group the results by the campus column to get the sum of degrees granted by each Orange county campus after 2000."}, {'question': 'What campus had more than 400 total enrollment but more than 200 full time enrollment in year 1956?', 'sql_query': 'SELECT T1.campus FROM campuses AS t1 JOIN enrollments AS t2 ON t1.id  =  t2.campus WHERE t2.year  =  1956 AND totalenrollment_ay  >  400 AND FTE_AY  >  200', 'db_id': 'csu_1', 'hardness': 'medium', 'cot': 'To find the campus that had more than 400 total enrollment but more than 200 full-time enrollment in the year 1956, we first need to JOIN the "Campuses" table with the "Enrollments" table on the campus ID. Then, we filter the results by specifying the conditions: the year is 1956, the total enrollment (TotalEnrollment_AY) is greater than 400, and the full-time enrollment (FTE_AY) is greater than 200.\n\nBy executing this SQL query, we are retrieving the campus that meets these criteria and displaying its campus identifier.'}], 'school_bus': [{'question': 'Show all home cities except for those having a driver older than 40.', 'sql_query': 'SELECT home_city FROM driver EXCEPT SELECT home_city FROM driver WHERE age  >  40', 'db_id': 'school_bus', 'hardness': 'hard', 'cot': 'First, the SQL query retrieves the home cities from the "driver" table. Then, it filters out the home cities where the age of the driver is greater than 40 using the EXCEPT keyword. This means that the final result will show all home cities except for those where the driver is older than 40 years old.'}, {'question': 'Show the school name and driver name for all school buses.', 'sql_query': 'SELECT T2.school ,  T3.name FROM school_bus AS T1 JOIN school AS T2 ON T1.school_id  =  T2.school_id JOIN driver AS T3 ON T1.driver_id  =  T3.driver_id', 'db_id': 'school_bus', 'hardness': 'medium', 'cot': 'The SQL query retrieves data from the "school_bus" table along with information from the "school" and "driver" tables. It joins these tables based on the foreign key relationships between the tables. \n\n1. The query starts by selecting the school name (retrieved as T2.school) and driver name (retrieved as T3.name) from the tables.\n\n2. It then performs a JOIN operation on the "school_bus" table (aliased as T1) with the "school" table (aliased as T2) based on the matching school IDs (T1.school_id = T2.school_id).\n\n3. Next, it performs another JOIN operation on the result of the previous join with the "driver" table (aliased as T3) based on the matching driver IDs (T1.driver_id = T3.driver_id).\n\n4. Finally, the query retrieves the school name and driver name for all school buses by linking the necessary information from the three tables using the JOIN operations.'}], 'insurance_fnol': [{'question': 'Which customers do not have a first notification of loss record? Give me the customer names.', 'sql_query': 'SELECT customer_name FROM customers EXCEPT SELECT t1.customer_name FROM customers AS t1 JOIN first_notification_of_loss AS t2 ON t1.customer_id  =  t2.customer_id', 'db_id': 'insurance_fnol', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `customer_name` column from the `customers` table.\n2. It then uses the `EXCEPT` operator to exclude the customers who have a first notification of loss record.\n3. To find the customers who do not have a first notification of loss record, it performs a left join between the `customers` table and the `first_notification_of_loss` table (aliased as t1 and t2 respectively) on the `customer_id` column.\n4. The join condition ensures that only the customers with a matching `customer_id` in the `first_notification_of_loss` table are included in the result set.\n5. By using the `EXCEPT` operator, the query returns only the `customer_name` values from the `customers` table that do not have a corresponding record in the `first_notification_of_loss` table.\n6. The final result will be a list of customer names who do not have a first notification of loss record associated with them.'}, {'question': 'What are the IDs of customers who have "Diana" in part of their names?', 'sql_query': 'SELECT customer_id FROM customers WHERE customer_name LIKE "%Diana%"', 'db_id': 'insurance_fnol', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the `customer_id` from the `Customers` table.\n2. It is filtering the rows by using the `WHERE` clause with the condition `customer_name LIKE "%Diana%"`. This condition searches for customer names that contain the substring "Diana" anywhere in the name.\n3. The `%` symbol in the `LIKE` operator is a wildcard that matches any sequence of characters, so `%Diana%` will match any customer names that have "Diana" as a substring.\n4. The query will return the IDs of customers whose names contain "Diana".'}], 'imdb': [{'question': 'Who is the director of the movie " James Bond " ?', 'sql_query': 'SELECT t2.name FROM director AS t2 JOIN directed_by AS t1 ON t2.did  =  t1.did JOIN movie AS t3 ON t3.mid  =  t1.msid WHERE t3.title  =  "James Bond";', 'db_id': 'imdb', 'hardness': 'hard', 'cot': 'This SQL query selects the name of the director of the movie "James Bond". It achieves this by joining the `director` table (aliased as t2) with the `directed_by` table (aliased as t1) on the director\'s ID and joining the `movie` table (aliased as t3) with the `directed_by` table on the movie\'s ID. It then filters the result based on the movie title being "James Bond" to retrieve the name of the director responsible for this movie.'}, {'question': 'Find all actors who were born in " New York City " in 1984', 'sql_query': 'SELECT name FROM actor WHERE birth_city  =  "New York City" AND birth_year  =  1984;', 'db_id': 'imdb', 'hardness': 'medium', 'cot': 'This SQL query selects the names of actors from the "actor" table where the birth city is "New York City" and the birth year is 1984. The query filters the data based on the conditions specified in the WHERE clause, returning only the names of actors who meet both criteria.'}], 'customers_and_invoices': [{'question': 'What are teh names of the different products, as well as the number of customers who have ordered each product.', 'sql_query': 'SELECT T2.product_name ,  count(*) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T3.order_id  =  T1.order_id GROUP BY T2.product_name', 'db_id': 'customers_and_invoices', 'hardness': 'hard', 'cot': 'The SQL query retrieves the names of different products and the number of customers who have ordered each product. \n\n1. We start by joining the `Order_Items` table (aliased as T1) with the `Products` table (aliased as T2) on the `product_id` column to get the product details for each order item.\n  \n2. Next, we join the result from step 1 with the `Orders` table (aliased as T3) on the `order_id` column to link the orders to the products they contain.\n\n3. We then group the result by the `product_name` from the `Products` table (T2) to get a distinct list of product names along with the count of how many customers have ordered each product.\n\nTherefore, the final result would show the names of different products and the number of customers who have ordered each product.'}, {'question': 'Show the number of customers for each gender.', 'sql_query': 'SELECT gender ,  count(*) FROM Customers GROUP BY gender', 'db_id': 'customers_and_invoices', 'hardness': 'medium', 'cot': "1. The SQL query starts by selecting the 'gender' column and applying an aggregation function 'COUNT(*)' on all rows in the 'Customers' table.\n2. The data is then grouped by the 'gender' column using the 'GROUP BY' clause.\n3. This query will count the number of customers for each unique gender present in the 'Customers' table.\n4. The result will show the gender values along with the count of customers belonging to each gender group."}], 'voter_2': [{'question': 'What are the distinct first names of the students who have vice president votes and reside in a city whose city code is not PIT?', 'sql_query': 'SELECT DISTINCT T1.Fname FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  T2.VICE_PRESIDENT_Vote EXCEPT SELECT DISTINCT Fname FROM STUDENT WHERE city_code  =  "PIT"', 'db_id': 'voter_2', 'hardness': 'hard', 'cot': '1. We are selecting distinct first names (Fname) of students who have vice president votes and meet a certain condition regarding their city code.\n2. We start by joining the `Student` table as T1 with the `Voting_record` table as T2 based on the condition that T1.StuID matches T2.VICE_PRESIDENT_Vote.\n3. The JOIN operation helps us link the student information with their corresponding vice president votes from the voting record.\n4. We then use the EXCEPT keyword to remove the distinct first names of students who reside in a city with the city code "PIT".\n5. The subquery `SELECT DISTINCT Fname FROM STUDENT WHERE city_code = "PIT"` is subtracted from the result of the join operation to get the desired distinct first names of students meeting the specified criteria.'}, {'question': 'Which students live in the city with code "NYC" and have class senator votes in the spring election cycle? Count the numbers.', 'sql_query': 'SELECT count(*) FROM STUDENT AS T1 JOIN VOTING_RECORD AS T2 ON T1.StuID  =  Class_Senator_Vote WHERE T1.city_code  =  "NYC" AND T2.Election_Cycle  =  "Spring"', 'db_id': 'voter_2', 'hardness': 'medium', 'cot': '1. The SQL query is counting the number of students who live in the city with the code "NYC" and have class senator votes in the spring election cycle.\n2. It first joins the Student table (aliased as T1) with the Voting_record table (aliased as T2) using the Student ID (StuID) and the Class Senator Vote.\n3. The condition specified in the query is that the city code in the Student table should be "NYC" and the election cycle in the Voting_record table should be "Spring".\n4. By counting the number of resulting records, the query provides the total count of students meeting the specified criteria.'}], 'school_finance': [{'question': 'What are the mascots for schools with enrollments above the average?', 'sql_query': 'SELECT mascot FROM school WHERE enrollment  >  (SELECT avg(enrollment) FROM school)', 'db_id': 'school_finance', 'hardness': 'hard', 'cot': 'The SQL query retrieves the mascots of schools where the enrollment is above the average enrollment of all schools. \n\n1. The subquery `(SELECT avg(enrollment) FROM school)` calculates the average enrollment of all schools.\n2. The main query `SELECT mascot FROM school WHERE enrollment > (SELECT avg(enrollment) FROM school)` filters and selects the mascots of schools whose enrollment is greater than the average enrollment calculated in the subquery.'}, {'question': 'Count the number of budgets in year 2001 or before whose budgeted amount is greater than 3000', 'sql_query': 'SELECT count(*) FROM budget WHERE budgeted  >  3000 AND YEAR  <=  2001', 'db_id': 'school_finance', 'hardness': 'medium', 'cot': 'We are counting the number of budgets from the "budget" table where the budgeted amount is greater than 3000 and the year is 2001 or earlier. This query is filtering budgets based on two conditions: budgeted amount and year. We are interested in budgets with amounts exceeding 3000 and which were allocated in the year 2001 or before. By using the "count(*)" function, we are instructing the database to return the number of rows that satisfy both conditions.'}], 'activity_1': [{'question': 'Show the ids of all the faculty members who participate in an activity and advise a student.', 'sql_query': 'SELECT FacID FROM Faculty_participates_in INTERSECT SELECT advisor FROM Student', 'db_id': 'activity_1', 'hardness': 'hard', 'cot': 'This SQL query retrieves the Faculty IDs of faculty members who participate in an activity and also advise a student. \n\n1. The query starts by selecting the Faculty IDs (FacID) from the table `Faculty_Participates_in`.\n2. It then uses the `INTERSECT` keyword to find the intersection of this result with the selection of advisor IDs from the `Student` table.\n3. By intersecting these two sets of data, the query effectively identifies the Faculty members who are both participating in an activity and advising a student. \n4. The final result will be the Faculty IDs of those specific faculty members who meet both these criteria.'}, {'question': 'Show the phone, room, and building for the faculty named Jerry Prince.', 'sql_query': 'SELECT phone ,  room ,  building FROM Faculty WHERE Fname  =  "Jerry" AND Lname  =  "Prince"', 'db_id': 'activity_1', 'hardness': 'medium', 'cot': 'To retrieve the phone number, room, and building information for the faculty member named Jerry Prince, we need to query the "Faculty" table. We use the SELECT statement to specify the columns we want to retrieve, which are phone, room, and building. The WHERE clause is used to filter the results based on the conditions that the first name (Fname) should be "Jerry" and the last name (Lname) should be "Prince". This will ensure that we only fetch the information related to the faculty member with the name Jerry Prince.'}], 'sakila_1': [{'question': 'What are the payment dates for any payments that have an amount greater than 10 or were handled by a staff member with the first name Elsa?', 'sql_query': "SELECT payment_date FROM payment WHERE amount  >  10 UNION SELECT T1.payment_date FROM payment AS T1 JOIN staff AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.first_name  =  'Elsa'", 'db_id': 'sakila_1', 'hardness': 'hard', 'cot': "1. The SQL query starts by selecting the payment dates from the `payment` table where the amount is greater than 10.\n2. It then uses the UNION operator to combine the results with the payment dates from the `payment` table (aliased as T1) that are linked to a staff member (T2) with the first name 'Elsa'.\n3. The JOIN condition connects the payment entries with the staff table based on matching staff_id.\n4. The query retrieves the payment dates for any payments that either have an amount greater than 10 or were processed by a staff member named Elsa."}, {'question': 'Where does the staff member with the first name Elsa live?', 'sql_query': "SELECT T2.address FROM staff AS T1 JOIN address AS T2 ON T1.address_id  =  T2.address_id WHERE T1.first_name  =  'Elsa'", 'db_id': 'sakila_1', 'hardness': 'medium', 'cot': "1. We start by selecting data from the 'staff' table aliased as T1.\n2. We want to join this data with the 'address' table aliased as T2 based on the common column 'address_id'.\n3. The condition specifies that we want to retrieve the address of the staff member with the first name 'Elsa'.\n4. By executing this query, we will retrieve the address where the staff member named Elsa lives."}], 'student_1': [{'question': 'Find the classroom that the most students use.', 'sql_query': 'SELECT classroom FROM list GROUP BY classroom ORDER BY count(*) DESC LIMIT 1', 'db_id': 'student_1', 'hardness': 'hard', 'cot': "- The SQL query starts by selecting the 'classroom' column from the 'list' table.\n- It then groups the results by the 'classroom' column. This means that rows with the same 'classroom' value are combined into groups.\n- The query then counts the number of students in each group (classroom) using the 'count(*)' function.\n- It orders the groups in descending order based on the count of students in each classroom, using the 'ORDER BY count(*) DESC' clause.\n- Finally, the 'LIMIT 1' clause ensures that only the first row (with the highest count of students) is returned as the output, giving the classroom that the most students use."}, {'question': 'For each grade 0 classroom, report the total number of students.', 'sql_query': 'SELECT classroom ,  count(*) FROM list WHERE grade  =  "0" GROUP BY classroom', 'db_id': 'student_1', 'hardness': 'medium', 'cot': '1. We are selecting data from the "list" table.\n2. We are filtering the data to only include rows where the "Grade" column has a value of "0".\n3. We are grouping the results by the "Classroom" column.\n4. We are using the COUNT(*) function to count the number of rows for each unique value in the "Classroom" column, which gives us the total number of students in each grade 0 classroom.'}], 'college_3': [{'question': 'Give the maximum and minimum gradepoints for students living in NYC?', 'sql_query': 'SELECT max(T2.gradepoint) ,  min(T2.gradepoint) FROM ENROLLED_IN AS T1 JOIN GRADECONVERSION AS T2 JOIN STUDENT AS T3 ON T1.Grade  =  T2.lettergrade AND T1.StuID  =  T3.StuID WHERE T3.city_code  =  "NYC"', 'db_id': 'college_3', 'hardness': 'hard', 'cot': '1. We start by looking at the table relationships in the SQL query. \n2. The query involves joining the tables ENROLLED_IN (T1), GRADECONVERSION (T2), and STUDENT (T3) based on certain conditions.\n3. The JOIN conditions are specified as T1.Grade = T2.lettergrade and T1.StuID = T3.StuID, indicating that we are connecting the tables based on the Grade of the student enrolled in a course and the Student ID.\n4. The WHERE clause is used to filter the results based on the condition that T3.city_code = "NYC", which means we are interested only in students living in New York City.\n5. The SELECT statement is used to retrieve the maximum and minimum gradepoints by selecting max(T2.gradepoint) and min(T2.gradepoint) respectively.\n6. This query will return the maximum and minimum gradepoints for students living in New York City.'}, {'question': 'Find the department name and room of the course INTRODUCTION TO COMPUTER SCIENCE.', 'sql_query': 'SELECT T2.Dname ,  T2.Room FROM COURSE AS T1 JOIN DEPARTMENT AS T2 ON T1.DNO  =  T2.DNO WHERE T1.CName  =  "INTRODUCTION TO COMPUTER SCIENCE"', 'db_id': 'college_3', 'hardness': 'medium', 'cot': '- The SQL query is selecting data from the tables COURSE (aliased as T1) and DEPARTMENT (aliased as T2).\n- The query is performing an inner join between the tables COURSE and DEPARTMENT using the common column DNO (Department Number).\n- The condition for the join is that the DNO in the COURSE table must match the DNO in the DEPARTMENT table.\n- The WHERE clause specifies the filter condition that the course name (CName) in the COURSE table must be "INTRODUCTION TO COMPUTER SCIENCE".\n- The SELECT statement retrieves the Department name (DName) and room number (Room) from the DEPARTMENT table.\n- Therefore, the query is retrieving the department name and room of the course "INTRODUCTION TO COMPUTER SCIENCE".'}], 'manufacturer': [{'question': 'Find the id and number of shops for the company that produces the most expensive furniture.', 'sql_query': 'SELECT t1.manufacturer_id ,  t1.num_of_shops FROM manufacturer AS t1 JOIN furniture_manufacte AS t2 ON t1.manufacturer_id  =  t2.manufacturer_id ORDER BY t2.Price_in_Dollar DESC LIMIT 1', 'db_id': 'manufacturer', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the "manufacturer_id" and "num_of_shops" from the "manufacturer" table (aliased as t1) and the "furniture_manufacte" table (aliased as t2).\n\n2. It then joins the "manufacturer" table with the "furniture_manufacte" table on the "manufacturer_id" column to link the two tables together based on the common manufacturer ID.\n\n3. The query sorts the results in descending order based on the "Price_in_Dollar" column from the "furniture_manufacte" table using the ORDER BY clause.\n\n4. The LIMIT 1 at the end of the query ensures that only the first result (the most expensive furniture) is returned based on the ordering done in the previous step.\n\n5. Therefore, the query will retrieve the manufacturer ID and the number of shops for the company that produces the most expensive furniture.'}, {'question': 'Find the name and component amount of the least popular furniture.', 'sql_query': 'SELECT name ,  Num_of_Component FROM furniture ORDER BY market_rate LIMIT 1', 'db_id': 'manufacturer', 'hardness': 'medium', 'cot': '1. **Retrieve data**: We start by selecting the columns "name" and "Num_of_Component" from the "furniture" table.\n2. **Ordering**: We then order the results by "market_rate" in ascending order. This will arrange the furniture items from the least to the most popular based on their market rates.\n3. **Limiting results**: Finally, we limit the output to just the first row using the LIMIT 1 clause. This will give us the least popular furniture item.\n4. **Result**: The query will return the name and the component amount of the least popular furniture based on the market rate.'}], 'driving_school': [{'question': 'What are the the lesson ids of all staff taught by Janessa Sawayn whose nickname has the letter s?', 'sql_query': 'SELECT T1.lesson_id FROM Lessons AS T1 JOIN Staff AS T2 ON T1.staff_id = T2.staff_id WHERE T2.first_name = "Janessa" AND T2.last_name = "Sawayn" AND nickname LIKE "%s%";', 'db_id': 'driving_school', 'hardness': 'hard', 'cot': '- The SQL query is retrieving data from the tables Lessons (aliased as T1) and Staff (aliased as T2) through a JOIN operation.\n- The JOIN condition is based on matching the staff_id from Lessons table (T1) with the staff_id from Staff table (T2).\n- There are specific conditions applied using the WHERE clause to filter the results:\n  - The first_name in Staff table should be "Janessa".\n  - The last_name in Staff table should be "Sawayn".\n  - The nickname column in the Staff table should contain the letter \'s\' (case insensitive) anywhere in the nickname.\n- The columns selected for the output are lesson_id from the Lessons table (aliased as T1).\n- This SQL query aims to retrieve the lesson_ids of all the lessons taught by the staff member whose first name is "Janessa" Sawayn and whose nickname contains the letter \'s\'.'}, {'question': 'What is zip code of customer with first name as Carole and last name as Bernhard?', 'sql_query': 'SELECT T2.zip_postcode FROM Customers AS T1 JOIN Addresses AS T2 ON T1.customer_address_id = T2.address_id WHERE T1.first_name = "Carole" AND T1.last_name = "Bernhard"', 'db_id': 'driving_school', 'hardness': 'medium', 'cot': '1. We are looking for the zip code of a customer with the first name "Carole" and the last name "Bernhard".\n2. To retrieve this information, we need to join the `Customers` table (aliased as T1) with the `Addresses` table (aliased as T2) based on the `customer_address_id` in `Customers` matching the `address_id` in `Addresses`.\n3. We specifically filter the data to only include records where the first name is "Carole" and the last name is "Bernhard" using the WHERE clause.\n4. The SELECT statement specifies that we want to retrieve the `zip_postcode` from the `Addresses` table where the customer\'s first name is "Carole" and last name is "Bernhard".\n5. The query will then return the zip code of the customer with the first name "Carole" and the last name "Bernhard".'}], 'scientist_1': [{'question': 'What are the names of projects that have taken longer than the average number of hours for all projects?', 'sql_query': 'SELECT name FROM projects WHERE hours  >  (SELECT avg(hours) FROM projects)', 'db_id': 'scientist_1', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `name` column from the `projects` table.\n2. The `WHERE` clause filters the results based on the condition that the `hours` column is greater than the result of a subquery.\n3. Inside the subquery, the `avg(hours)` function is used to calculate the average number of hours for all projects in the `projects` table.\n4. Therefore, the main query retrieves the names of projects that have taken longer than the average number of hours for all projects.'}, {'question': 'What is the name of the project with the most hours?', 'sql_query': 'SELECT name FROM projects ORDER BY hours DESC LIMIT 1', 'db_id': 'scientist_1', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the `name` column from the `Projects` table.\n2. It then orders the results in descending order based on the `hours` column. This means projects with the highest number of hours will appear first.\n3. The `LIMIT 1` clause is used to restrict the result set to only one row, effectively returning the project with the most hours.\n4. Therefore, the query will return the name of the project with the most hours from the `Projects` table.'}], 'entertainment_awards': [{'question': "In which year are there festivals both inside the 'United States' and outside the 'United States'?", 'sql_query': "SELECT YEAR FROM festival_detail WHERE LOCATION  =  'United States' INTERSECT SELECT YEAR FROM festival_detail WHERE LOCATION != 'United States'", 'db_id': 'entertainment_awards', 'hardness': 'hard', 'cot': "1. The SQL query starts by selecting the 'YEAR' column from the 'festival_detail' table.\n2. It then filters the results by selecting only the rows where the 'LOCATION' is equal to 'United States' in the first part of the query.\n3. In the second part of the query, it also selects the 'YEAR' column from the 'festival_detail' table but this time filters the results by selecting only the rows where the 'LOCATION' is not equal to 'United States'.\n4. The INTERSECT keyword is used to combine the results of both parts of the query to return the intersection of the selected years where festivals are hosted both inside and outside the 'United States'.\n5. The final result will be the years in which there are festivals that took place both inside and outside the 'United States'."}, {'question': 'Show the names of the three most recent festivals.', 'sql_query': 'SELECT Festival_Name FROM festival_detail ORDER BY YEAR DESC LIMIT 3', 'db_id': 'entertainment_awards', 'hardness': 'medium', 'cot': '1. The SQL query selects the `Festival_Name` column from the `festival_detail` table.\n2. The records are ordered by the `YEAR` column in descending order, meaning the most recent festivals will appear first.\n3. The `LIMIT 3` clause ensures that only the top 3 results (most recent festivals) are returned.\n4. Therefore, the query will show the names of the three most recent festivals.'}], 'county_public_safety': [{'question': 'Show the names of cities in counties that have a crime rate less than 100.', 'sql_query': 'SELECT name FROM city WHERE county_id IN (SELECT county_id FROM county_public_safety WHERE Crime_rate  <  100)', 'db_id': 'county_public_safety', 'hardness': 'hard', 'cot': '1. The SQL query is selecting the names of cities from the "city" table.\n2. The subquery is retrieving the county IDs from the "county_public_safety" table where the crime rate is less than 100.\n3. The main query is filtering cities based on the county IDs obtained from the subquery.\n4. By using the WHERE clause with the condition "county_id IN (subquery)", we are only selecting cities that belong to counties with a crime rate less than 100.\n5. The final result will display the names of cities located in counties with a crime rate less than 100.'}, {'question': 'List the name of the county with the largest population.', 'sql_query': 'SELECT Name FROM county_public_safety ORDER BY Population DESC LIMIT 1', 'db_id': 'county_public_safety', 'hardness': 'medium', 'cot': '- The SQL query is selecting the column "Name" from the table "county_public_safety."\n- It is using the ORDER BY clause to sort the counties by their "Population" in descending order.\n- The query then limits the result to only one row using the LIMIT 1 clause.\n- This will return the name of the county with the largest population.'}], 'election_representative': [{'question': 'What is the party that has the largest number of representatives?', 'sql_query': 'SELECT Party ,  COUNT(*) FROM representative GROUP BY Party ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'election_representative', 'hardness': 'hard', 'cot': '1. The SQL query retrieves the party and the count of representatives associated with each party from the "representative" table.\n2. It then groups the result by the "Party" column to count the number of representatives for each party.\n3. The query orders the results in descending order based on the count of representatives.\n4. Finally, it limits the output to only the first row, which corresponds to the party with the largest number of representatives.'}, {'question': 'What are the life spans of representatives from New York state or Indiana state?', 'sql_query': 'SELECT Lifespan FROM representative WHERE State  =  "New York" OR State  =  "Indiana"', 'db_id': 'election_representative', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the "Lifespan" attribute from the "representative" table.\n2. It specifies the condition using the WHERE clause to only retrieve data where the "State" is either "New York" or "Indiana".\n3. This means that the query will return the life spans of representatives who belong to either the state of New York or Indiana.'}], 'riding_club': [{'question': 'Show the names and genders of players with a coach starting after 2011.', 'sql_query': 'SELECT T3.Player_name ,  T3.gender FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID WHERE T1.Starting_year  >  2011', 'db_id': 'riding_club', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting data from the `player_coach` table (aliased as T1), the `coach` table (aliased as T2), and the `player` table (aliased as T3).\n- It then specifies the conditions for joining these tables using the foreign key relationships: T1.Coach_ID = T2.Coach_ID and T1.Player_ID = T3.Player_ID.\n- The query filters the results by adding a condition in the WHERE clause: T1.Starting_year > 2011. This filters out coach-player pairs where the coach started after the year 2011.\n- Finally, the SELECT statement specifies the columns to be displayed: T3.Player_name and T3.gender. These are the names and genders of players with a coach starting after 2011.'}, {'question': 'List the name and residence for players whose occupation is not "Researcher".', 'sql_query': 'SELECT Player_name ,  residence FROM player WHERE Occupation != "Researcher"', 'db_id': 'riding_club', 'hardness': 'medium', 'cot': '1. We are selecting data from the "player" table.\n2. We are specifically interested in two columns: "Player_name" and "Residence".\n3. The condition specified in the WHERE clause is Occupation != "Researcher", which means we want to filter out players whose occupation is not "Researcher".\n4. Therefore, the query will return the names and residences of players who have occupations other than "Researcher".'}], 'manufactory_1': [{'question': 'Find the total revenue of companies whose revenue is larger than the revenue of some companies based in Austin.', 'sql_query': "SELECT sum(revenue) FROM manufacturers WHERE revenue  >  (SELECT min(revenue) FROM manufacturers WHERE headquarter  =  'Austin')", 'db_id': 'manufactory_1', 'hardness': 'hard', 'cot': "To find the total revenue of companies whose revenue is larger than the revenue of some companies based in Austin, the query is structured in a way that first retrieves the minimum revenue of companies based in Austin using a subquery: \n\n1. The inner subquery `SELECT min(revenue) FROM manufacturers WHERE headquarter = 'Austin'` is used to find the minimum revenue among the companies based in Austin.\n\n2. Then, the main query compares this minimum revenue value with the revenue of other companies in the `manufacturers` table using the condition `WHERE revenue > (...)`.\n\n3. The main query calculates the sum of revenues for only those companies that have a revenue greater than the minimum revenue of companies based in Austin using the `SUM(revenue)` function.\n\nAs a result, this query will return the total revenue of companies whose revenue is larger than the revenue of some companies with their headquarters in Austin."}, {'question': 'Find the total revenue of companies of each founder.', 'sql_query': 'SELECT sum(revenue) ,  founder FROM manufacturers GROUP BY founder', 'db_id': 'manufactory_1', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the sum of revenue and the founder from the "manufacturers" table.\n2. It then groups the results by the founder column using the GROUP BY clause.\n3. This query will group the total revenue based on the founder, providing the total revenue of companies founded by each founder.'}], 'ship_1': [{'question': 'In which year were most of ships built?', 'sql_query': 'SELECT built_year FROM ship GROUP BY built_year ORDER BY count(*) DESC LIMIT 1', 'db_id': 'ship_1', 'hardness': 'hard', 'cot': "1. We are starting by selecting the 'built_year' column from the 'Ship' table.\n2. We then group the results by 'built_year', which means all the ship records with the same build year will be grouped together.\n3. Next, we are ordering these groups in descending order based on the count of records in each group. This will show which year has the most ships built.\n4. Finally, we use the LIMIT 1 clause to only return the first row which will give us the year in which most ships were built."}, {'question': 'Count the number of captains younger than 50 of each rank.', 'sql_query': 'SELECT count(*) ,  rank FROM captain WHERE age  <  50 GROUP BY rank', 'db_id': 'ship_1', 'hardness': 'medium', 'cot': 'To count the number of captains younger than 50 of each rank, we will first filter the captains based on their age being less than 50 using the `WHERE` clause. Then, we will use the `GROUP BY` clause along with the `COUNT(*)` function to group the captains based on their rank and count the number of captains for each rank who meet the age criteria. This will give us the desired output showing the count of captains younger than 50 for each rank.'}], 'solvency_ii': [{'question': 'Show the product type codes that have both products with price higher than 4500 and products with price lower than 3000.', 'sql_query': 'SELECT Product_Type_Code FROM Products WHERE Product_Price  >  4500 INTERSECT SELECT Product_Type_Code FROM Products WHERE Product_Price  <  3000', 'db_id': 'solvency_ii', 'hardness': 'hard', 'cot': 'We are trying to find the product type codes that have both products with a price higher than 4500 and products with a price lower than 3000. \n\nTo achieve this, we first need to retrieve the product type codes of products with a price higher than 4500. We can do this by selecting the Product_Type_Code from the Products table where Product_Price is greater than 4500.\n\nNext, we need to retrieve the product type codes of products with a price lower than 3000. We can achieve this by selecting the Product_Type_Code from the Products table where Product_Price is less than 3000.\n\nUsing the INTERSECT operator between these two queries will give us the common product type codes that satisfy both conditions - having products with prices higher than 4500 and lower than 3000.'}, {'question': 'What are the names and type codes of products?', 'sql_query': 'SELECT Product_Name ,  Product_Type_Code FROM Products', 'db_id': 'solvency_ii', 'hardness': 'medium', 'cot': '1. The SQL query is requesting data from the table "Products".\n2. The columns being selected are "Product_Name" and "Product_Type_Code".\n3. The query is asking for the names and type codes of products.\n4. By executing this query, we will retrieve a list of product names along with their respective type codes from the "Products" table.\n5. This will provide us with the information about the names and type codes of all the products stored in the database.'}], 'department_store': [{'question': 'What are the distinct names and phone numbers for suppliers who have red jeans?', 'sql_query': 'SELECT DISTINCT T1.supplier_name ,  T1.supplier_phone FROM suppliers AS T1 JOIN product_suppliers AS T2 ON T1.supplier_id  =  T2.supplier_id JOIN products AS T3 ON T2.product_id  =  T3.product_id WHERE T3.product_name  =  "red jeans"', 'db_id': 'department_store', 'hardness': 'hard', 'cot': 'To answer the question "What are the distinct names and phone numbers for suppliers who have red jeans?", we need to retrieve information from the `Suppliers`, `Product_Suppliers`, and `Products` tables.\n\n1. We JOIN the `Suppliers` table (aliased as T1) with the `Product_Suppliers` table (aliased as T2) on the `supplier_id`.\n2. Then, we JOIN the result with the `Products` table (aliased as T3) on the `product_id`.\n3. We apply the condition that the `product_name` in the `Products` table should be equal to "red jeans".\n4. Finally, we SELECT the distinct `supplier_name` and `supplier_phone` from the joined tables to get the unique names and phone numbers of suppliers who supply red jeans.'}, {'question': 'What are the ids of the top three products that were purchased in the largest amount?', 'sql_query': 'SELECT product_id FROM product_suppliers ORDER BY total_amount_purchased DESC LIMIT 3', 'db_id': 'department_store', 'hardness': 'medium', 'cot': '1. The SQL query selects the `product_id` from the `Product_Suppliers` table.\n2. It orders the results by the `total_amount_purchased` column in descending order, meaning that the products with the largest total amount purchased will appear first.\n3. The `LIMIT 3` clause restricts the output to only the top three results, i.e., the products that were purchased in the largest amounts.\n4. Therefore, the query will return the `product_id` of the top three products that were purchased in the largest amount.\n5. This query helps identify the most popular or highest-selling products based on the total quantity purchased.'}], 'scholar': [{'question': 'What was the conference name that approved Trophic Cascade ?', 'sql_query': 'SELECT DISTINCT t3.venueid FROM paperkeyphrase AS t2 JOIN keyphrase AS t1 ON t2.keyphraseid  =  t1.keyphraseid JOIN paper AS t3 ON t3.paperid  =  t2.paperid WHERE t1.keyphrasename  =  "Trophic Cascade";', 'db_id': 'scholar', 'hardness': 'hard', 'cot': '1. The SQL query begins by selecting distinct `venueid` from the `paper` table alias as t3.\n2. It then joins the `paperkeyphrase` table alias as t2 with the `keyphrase` table alias as t1 based on the condition that the `keyphraseId` in t2 is equal to the `keyphraseId` in t1.\n3. Further, it joins the `paper` table t3 with the result from the previous join where the `paperId` in t3 is equal to the `paperId` in t2.\n4. The WHERE clause filters the results where the `keyphraseName` from the `keyphrase` table t1 is "Trophic Cascade".\n5. Thus, by executing this query, we can find the distinct `venueId` where papers related to the keyphrase "Trophic Cascade" have been approved.'}, {'question': 'How many paper does Christopher D. Manning have ?', 'sql_query': 'SELECT DISTINCT COUNT ( DISTINCT t2.paperid ) FROM writes AS t2 JOIN author AS t1 ON t2.authorid  =  t1.authorid WHERE t1.authorname  =  "Christopher D. Manning";', 'db_id': 'scholar', 'hardness': 'medium', 'cot': '- We start by selecting the count of distinct paper IDs from the "writes" table as t2.\n- We perform an inner join between the "writes" table as t2 and the "author" table as t1 on the condition that the author IDs match (t2.authorid = t1.authorid).\n- We filter the result based on the condition that the author\'s name in the "author" table is "Christopher D. Manning" (t1.authorname = "Christopher D. Manning").\n- Finally, we return the count of distinct paper IDs written by Christopher D. Manning by counting the distinct values in t2.paperid.'}], 'insurance_policies': [{'question': 'Among all the claims, which settlements have a claimed amount that is no more than the average? List the claim start date.', 'sql_query': 'SELECT Date_Claim_Made FROM Claims WHERE Amount_Settled  <=  ( SELECT avg(Amount_Settled) FROM Claims )', 'db_id': 'insurance_policies', 'hardness': 'hard', 'cot': '1. The SQL query selects the `Date_Claim_Made` from the `Claims` table.\n2. It filters the claims based on a subquery result where it calculates the average `Amount_Settled` from all claims in the `Claims` table.\n3. The subquery is used to compare the `Amount_Settled` of each claim with the average `Amount_Settled`, and only those claims where the `Amount_Settled` is less than or equal to the average value are returned.\n4. The result will give us the `Date_Claim_Made` for those claims that have a settled amount that is no more than the average settled amount across all claims.'}, {'question': 'What are the claim dates and settlement dates of all the settlements?', 'sql_query': 'SELECT Date_Claim_Made ,  Date_Claim_Settled FROM Settlements', 'db_id': 'insurance_policies', 'hardness': 'medium', 'cot': "This SQL query selects the columns 'Date_Claim_Made' and 'Date_Claim_Settled' from the 'Settlements' table. It returns the claim dates and settlement dates of all the settlements in the database without any specific conditions or filtering applied."}], 'assets_maintenance': [{'question': 'Which assets did not incur any fault log? List the asset model.', 'sql_query': 'SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log)', 'db_id': 'assets_maintenance', 'hardness': 'hard', 'cot': '1. Start by understanding the SQL query:\n   - We are selecting the `asset_model` from the `Assets` table.\n   - The condition specifies that we want to find assets that do not have a corresponding entry in the `Fault_Log` table.\n\n2. The subquery `(SELECT asset_id FROM Fault_Log)` is used to get a list of all asset IDs that have entries in the `Fault_Log` table.\n\n3. The main query `SELECT asset_model FROM Assets WHERE asset_id NOT IN (...)` then retrieves the `asset_model` from the `Assets` table where the `asset_id` is not found in the list of asset IDs that have fault log entries.\n\n4. This query helps identify assets that have not incurred any faults based on the absence of their asset IDs in the `Fault_Log` table and returns the corresponding asset models.'}, {'question': "List all every engineer's first name, last name, details and coresponding skill description.", 'sql_query': 'SELECT T1.first_name ,  T1.last_name ,  T1.other_details ,  T3.skill_description FROM Maintenance_Engineers AS T1 JOIN Engineer_Skills AS T2 ON T1.engineer_id  =  T2.engineer_id JOIN Skills AS T3 ON T2.skill_id  =  T3.skill_id', 'db_id': 'assets_maintenance', 'hardness': 'medium', 'cot': '- Join the table `Maintenance_Engineers` with the table `Engineer_Skills` on `engineer_id` to get the engineers and their corresponding skills.\n- Join the result of the previous step with the table `Skills` on `skill_id` to fetch the skill descriptions for each engineer.\n- Select the `first_name`, `last_name`, `other_details` from the `Maintenance_Engineers` table and `skill_description` from the `Skills` table for each engineer to display their full name, details, and corresponding skill description.'}], 'tracking_software_problems': [{'question': 'What are the products that have problems reported after 1986-11-13? Give me the product id and the count of problems reported after 1986-11-13.', 'sql_query': 'SELECT count(*) ,  T2.product_id FROM problems AS T1 JOIN product AS T2 ON T1.product_id = T2.product_id WHERE T1.date_problem_reported > "1986-11-13" GROUP BY T2.product_id', 'db_id': 'tracking_software_problems', 'hardness': 'hard', 'cot': '1. We are selecting data from the `Problems` table (aliased as T1) and the `Product` table (aliased as T2).\n2. We are performing an inner join on the `product_id` column between the `Problems` table and the `Product` table.\n3. We are filtering the results to only include rows where the `date_problem_reported` in the `Problems` table is greater than "1986-11-13".\n4. We are grouping the results by the `product_id` from the `Product` table.\n5. We are selecting the count of rows in each group along with the `product_id` from the `Product` table.\n6. Finally, we will get the product id and the count of problems reported after 1986-11-13.'}, {'question': 'How many problems are there for product voluptatem?', 'sql_query': 'SELECT count(*) FROM product AS T1 JOIN problems AS T2 ON T1.product_id = T2.product_id WHERE T1.product_name = "voluptatem"', 'db_id': 'tracking_software_problems', 'hardness': 'medium', 'cot': '1. We start by looking at the SQL query given. The query is selecting and counting the number of records from two tables, Product (aliased as T1) and Problems (aliased as T2).\n\n2. The query joins the Product table with the Problems table using the product_id field which is common in both tables.\n\n3. The condition for the join is specified using the WHERE clause. It matches the product_name "voluptatem" specified in the Product table.\n\n4. By counting the number of records returned from this query, we can determine how many problems are associated with the product named "voluptatem".\n\n5. In essence, the SQL query is identifying the product with the name "voluptatem" in the Product table and then counting the number of associated problems for that product in the Problems table by matching the product_id.'}], 'movie_1': [{'question': 'Return reviewer name, movie title, stars, and ratingDate. And sort the data first by reviewer name, then by movie title, and lastly by number of stars.', 'sql_query': 'SELECT T3.name ,  T2.title ,  T1.stars ,  T1.ratingDate FROM Rating AS T1 JOIN Movie AS T2 ON T1.mID  =  T2.mID JOIN Reviewer AS T3 ON T1.rID  =  T3.rID ORDER BY T3.name ,  T2.title ,  T1.stars', 'db_id': 'movie_1', 'hardness': 'hard', 'cot': "1. The SQL query is selecting data from the Rating table (aliased as T1), Movie table (aliased as T2), and Reviewer table (aliased as T3) by joining them based on their respective foreign key relationships.\n2. The data selected includes the reviewer's name, movie title, stars given in the rating, and the rating date.\n3. The JOIN conditions connect the Rating table with the Movie table on the movie ID (mID) and the Rating table with the Reviewer table on the reviewer ID (rID).\n4. The ORDER BY clause sorts the result set first by reviewer name (T3.name), then by movie title (T2.title), and lastly by the number of stars (T1.stars)."}, {'question': 'For each movie that received more than 3 reviews, what is the average rating?', 'sql_query': 'SELECT mID ,  avg(stars) FROM Rating GROUP BY mID HAVING count(*)  >=  2', 'db_id': 'movie_1', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the movie ID (mID) and calculating the average stars from the Rating table.\n2. The data is grouped by movie ID (mID) using the GROUP BY clause, which means that the average rating will be calculated separately for each movie.\n3. The HAVING clause is used to filter the results. It specifies that only groups (movies) with a count of reviews greater than or equal to 2 should be included in the final result.\n4. Therefore, the query will return the movie IDs that received more than 2 reviews along with their average rating.'}], 'products_gen_characteristics': [{'question': 'List all the characteristic names and data types of product "cumin".', 'sql_query': 'SELECT t3.characteristic_name ,  t3.characteristic_data_type FROM products AS t1 JOIN product_characteristics AS t2 ON t1.product_id  =  t2.product_id JOIN CHARACTERISTICS AS t3 ON t2.characteristic_id  =  t3.characteristic_id WHERE t1.product_name  =  "cumin"', 'db_id': 'products_gen_characteristics', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting data from the "products" table aliasing it as t1.\n2. It then joins the "product_characteristics" table aliasing it as t2 using the product_id as the common attribute between the two tables.\n3. Another join is performed with the "Characteristics" table aliasing it as t3, this time using the characteristic_id to join with the previous join result.\n4. The WHERE clause filters the results based on the product_name which is "cumin".\n5. Finally, the query selects the characteristic_name and characteristic_data_type from the joined tables. '}, {'question': "Return the color code and description for the product with the name 'chervil'.", 'sql_query': 'SELECT t1.color_code ,  t2.color_description FROM products AS t1 JOIN ref_colors AS t2 ON t1.color_code  =  t2.color_code WHERE t1.product_name  =  "chervil"', 'db_id': 'products_gen_characteristics', 'hardness': 'medium', 'cot': '- The SQL query is selecting `color_code` and `color_description` columns.\n- The data is being retrieved from the `products` table aliased as `t1` and the `ref_colors` table aliased as `t2`.\n- The `JOIN` operation is being used to combine the `products` and `ref_colors` tables based on the matching `color_code`.\n- There is a condition specified in the `WHERE` clause to only select data where the `product_name` in the `products` table is equal to "chervil".\n- This query will return the color code and description for the product with the name \'chervil\'.'}], 'loan_1': [{'question': 'What is the average credit score for customers who have taken a loan?', 'sql_query': 'SELECT avg(credit_score) FROM customer WHERE cust_id IN (SELECT cust_id FROM loan)', 'db_id': 'loan_1', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the average credit score from the "customer" table.\n- To filter out only the customers who have taken a loan, a subquery is used. The subquery selects the customer IDs ("cust_id") from the "loan" table.\n- This means that only customers who have taken a loan will have their credit scores included in the average calculation.\n- The main query then calculates the average of these credit scores to provide the average credit score for customers who have taken a loan.'}, {'question': 'Find the name of customer who has the lowest credit score.', 'sql_query': 'SELECT cust_name FROM customer ORDER BY credit_score LIMIT 1', 'db_id': 'loan_1', 'hardness': 'medium', 'cot': 'To find the name of customer who has the lowest credit score, we need to retrieve the `cust_name` from the `customer` table.  \nWe can use the `ORDER BY` clause to sort the results based on the `credit_score` in ascending order.  \nBy using the `LIMIT 1` at the end of the query, we ensure that only the first row (customer) with the lowest credit score is returned.  \nThis way, the customer with the lowest credit score will be identified and their name will be displayed as the output.'}], 'dog_kennels': [{'question': 'Find the first names that are used for professionals or owners but are not used as dog names.', 'sql_query': 'SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs', 'db_id': 'dog_kennels', 'hardness': 'hard', 'cot': 'To start with, this SQL query retrieves the first names of all professionals and owners by performing a UNION operation on the `first_name` column from the `Professionals` table and the `Owners` table. This union operation combines the results of both queries into a single result set.\n\nNext, the SQL query applies the EXCEPT operator to subtract the first names of dogs from the previously obtained result set. The EXCEPT operator removes any duplicates and returns only the distinct first names that are present in the result set obtained from the UNION operation but are not found in the `name` column of the `Dogs` table.\n\nIn conclusion, this SQL query ultimately aims to identify the first names that are used for professionals or owners but are not used as dog names by combining data from different tables and then filtering out any overlapping names found in the `Dogs` table.'}, {'question': "Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.", 'sql_query': "SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'", 'db_id': 'dog_kennels', 'hardness': 'medium', 'cot': "1. The SQL query is selecting the columns `first_name`, `last_name`, and `email_address` from the table `Owners`.\n2. The query is filtering the results based on a condition using the `WHERE` clause.\n3. The condition specified is `state LIKE '%North%'`, which means it will match any state that contains the substring 'North'.\n4. Therefore, the query will retrieve the `first_name`, `last_name`, and `email_address` of the owners who live in states with names containing the substring 'North'."}], 'e_government': [{'question': 'Find the name of all the cities and states.', 'sql_query': 'SELECT town_city FROM addresses UNION SELECT state_province_county FROM addresses', 'db_id': 'e_government', 'hardness': 'hard', 'cot': '1. We are using the `UNION` operator to combine the results of two `SELECT` statements.\n2. The first `SELECT` statement retrieves the `town_city` from the `Addresses` table.\n3. The second `SELECT` statement retrieves the `state_province_county` from the `Addresses` table.\n4. By using `UNION`, we are combining the results of these two columns into a single result set.\n5. This query will return the unique names of all cities and states/provinces/counties stored in the `Addresses` table.'}, {'question': 'Find the name of the youngest organization.', 'sql_query': 'SELECT organization_name FROM organizations ORDER BY date_formed DESC LIMIT 1', 'db_id': 'e_government', 'hardness': 'medium', 'cot': '- The SQL query selects the `organization_name` from the `Organizations` table.\n- The records are ordered in descending order based on the `date_formed` column. This means the most recently formed organizations will be at the top.\n- Using the `LIMIT 1` clause, only the first record (which corresponds to the most recently formed organization) is returned.\n- Therefore, the query returns the name of the youngest organization, i.e., the most recently formed organization.'}], 'tracking_grants_for_research': [{'question': 'List the project details of the projects which did not hire any staff for a researcher role.', 'sql_query': "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )", 'db_id': 'tracking_grants_for_research', 'hardness': 'hard', 'cot': "1. We are selecting project_details from the Projects table.\n2. We are filtering out projects that have hired staff for a researcher role.\n3. To achieve this, we are using a subquery to select project_ids from the Project_Staff table where the role_code is 'researcher'.\n4. The main query then selects project_details from the Projects table where the project_id is not found in the subquery result.\n5. This query retrieves the project details of projects that did not hire any staff for a researcher role."}, {'question': "Which document type is described with the prefix 'Initial'?", 'sql_query': "SELECT document_type_code FROM Document_Types WHERE document_description LIKE 'Initial%'", 'db_id': 'tracking_grants_for_research', 'hardness': 'medium', 'cot': "1. The SQL query is selecting the 'document_type_code' from the 'Document_Types' table.\n2. The condition used in the WHERE clause is looking for 'document_description' that starts with the word 'Initial'.\n3. The '%' symbol in the LIKE operator is a wildcard that represents zero or more characters that can come after the specified pattern 'Initial'.\n4. This query is searching for a document type whose description starts with 'Initial'.\n5. The result will be the 'document_type_code' of the document type that matches the condition in the WHERE clause."}], 'film_rank': [{'question': 'List the title of films that do not have any market estimation.', 'sql_query': 'SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)', 'db_id': 'film_rank', 'hardness': 'hard', 'cot': 'This SQL query first selects the "Title" column from the "film" table. It then filters the results by checking the "Film_ID" values that are not present in the subquery result, which retrieves all "Film_ID" values from the "film_market_estimation" table. This means that the query will only return the titles of films that do not have any corresponding market estimations in the "film_market_estimation" table.'}, {'question': 'What is the average number of cities of markets with low film market estimate bigger than 10000?', 'sql_query': 'SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000', 'db_id': 'film_rank', 'hardness': 'medium', 'cot': '1. The SQL query begins by selecting the average of the "Number_cities" column from the "market" table, aliased as T2.\n2. The query then performs an inner join between the "film_market_estimation" table (aliased as T1) and the "market" table (aliased as T2) using the "Market_ID" column to match records.\n3. Next, a condition is applied using the WHERE clause to filter the joined results where the "Low_Estimate" value from T1 is greater than 10000.\n4. Finally, the query calculates the average number of cities of markets where the film market estimate is bigger than 10000.'}], 'academic': [{'question': 'return me the total citations of papers in PVLDB in each year .', 'sql_query': 'SELECT t2.year  ,  SUM ( t2.citation_num ) FROM publication AS t2 JOIN journal AS t1 ON t2.jid  =  t1.jid WHERE t1.name  =  "PVLDB" GROUP BY t2.year;', 'db_id': 'academic', 'hardness': 'hard', 'cot': '1. Retrieve data from the "publication" table and "journal" table where the publication is linked to a journal with the name "PVLDB".\n2. Join the tables on the journal ID to get the necessary data.\n3. Filter the data to include only publications from the journal "PVLDB".\n4. Group the results by the year of the publication.\n5. For each year, calculate the total number of citations by summing up the citation numbers of the publications.\n6. Return the result which includes the year and the total citations for papers in "PVLDB" for each year.'}, {'question': 'return me the total citations of papers in the VLDB conference in 2005 .', 'sql_query': 'SELECT SUM ( t2.citation_num ) FROM publication AS t2 JOIN conference AS t1 ON t2.cid  =  t1.cid WHERE t1.name  =  "VLDB" AND t2.year  =  2005;', 'db_id': 'academic', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the sum of the "citation_num" column from the "publication" table (aliased as t2).\n2. It then performs an inner join between the "publication" table (t2) and the "conference" table (aliased as t1) based on the condition that t2.cid (conference id in publication table) is equal to t1.cid (conference id in conference table).\n3. The query adds a WHERE clause to filter the results where the conference name in the "conference" table is equal to "VLDB" and the publication year in the "publication" table is 2005.\n4. The result will be the total citations of papers published in the VLDB conference in the year 2005.'}], 'customer_complaints': [{'question': 'How many customers are there in the customer type with the most customers?', 'sql_query': 'SELECT count(*) FROM customers GROUP BY customer_type_code ORDER BY count(*) DESC LIMIT 1', 'db_id': 'customer_complaints', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting all columns from the "Customers" table.\n2. The data is then grouped by the column "customer_type_code" to separate the customers based on their type.\n3. The query then calculates the count of customers in each customer type group using the COUNT(*) function.\n4. Next, the results are sorted in descending order based on the count of customers in each type group using the ORDER BY clause.\n5. Finally, the LIMIT 1 clause is used to limit the result to only the first row, which corresponds to the customer type with the most customers.\n6. The final result of this SQL query will be the count of customers in the customer type that has the highest number of customers in the database.'}, {'question': 'What is the average price of the products for each category?', 'sql_query': 'SELECT avg(product_price) ,  product_category_code FROM products GROUP BY product_category_code', 'db_id': 'customer_complaints', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the average product price and the product category code from the "Products" table.\n2. It uses the AVG() function to calculate the average product price for each category.\n3. The query groups the results by the product category code using the GROUP BY clause.\n4. This will give us the average price of products for each category in the database.'}], 'program_share': [{'question': 'Find the names of programs that are never broadcasted in the morning.', 'sql_query': 'SELECT name FROM program EXCEPT SELECT t1.name FROM program AS t1 JOIN broadcast AS t2 ON t1.program_id  =  t2.program_id WHERE t2.Time_of_day  =  "Morning"', 'db_id': 'program_share', 'hardness': 'hard', 'cot': 'To find the names of programs that are never broadcasted in the morning, we can use the EXCEPT operator in SQL. \n\n1. First, we select the names of all programs from the "program" table.\n2. Then, we use the EXCEPT operator to exclude the names of programs that are broadcasted in the morning.\n3. To identify the programs broadcasted in the morning, we join the "program" table with the "broadcast" table on the program_id column where the Time_of_day is "Morning".\n4. By using the EXCEPT operator, we get the names of programs that are never broadcasted in the morning.'}, {'question': 'Find the names of the channels that are broadcast in the morning.', 'sql_query': "SELECT t1.name FROM channel AS t1 JOIN broadcast AS t2 ON t1.channel_id  =  t2.channel_id WHERE t2.time_of_day  =  'Morning'", 'db_id': 'program_share', 'hardness': 'medium', 'cot': '1. We want to retrieve the names of the channels that are broadcast in the morning.\n2. To do this, we need to select the "name" column from the "channel" table.\n3. We need to join the "channel" table with the "broadcast" table based on the common column "Channel_ID".\n4. We specify the condition for the join where the time of day in the "broadcast" table is \'Morning\'.\n5. The query will return the names of the channels that have programs broadcasted in the morning.'}], 'medicine_enzyme_interaction': [{'question': 'What are the ids, names, and FDA approval status for medicines ordered by descending number of possible enzyme interactions?', 'sql_query': 'SELECT T1.id ,  T1.Name ,  T1.FDA_approved FROM medicine AS T1 JOIN medicine_enzyme_interaction AS T2 ON T2.medicine_id  =  T1.id GROUP BY T1.id ORDER BY count(*) DESC', 'db_id': 'medicine_enzyme_interaction', 'hardness': 'hard', 'cot': '- The SQL query is retrieving the IDs, names, and FDA approval status of medicines from the "medicine" table.\n- It joins the "medicine" table with the "medicine_enzyme_interaction" table on the condition that the medicine IDs match.\n- The query then groups the results by the ID of the medicines.\n- It then orders the results in descending order based on the count of enzyme interactions for each medicine.\n- The final result will display the requested information for medicines, sorted by the number of possible enzyme interactions they have, from highest to lowest.'}, {'question': 'List the names and the locations that the enzymes can make an effect.', 'sql_query': 'SELECT name ,  LOCATION FROM enzyme', 'db_id': 'medicine_enzyme_interaction', 'hardness': 'medium', 'cot': 'This SQL query selects the columns "name" and "LOCATION" from the "enzyme" table. By using the "SELECT" statement, we are retrieving specific columns from the table. The columns selected are "name" and "LOCATION". This query will return a result set that includes the names of enzymes and their respective locations where they can have an effect. The result will help us list the names of enzymes and the locations where these enzymes can make an effect.'}], 'local_govt_and_lot': [{'question': 'Which organizations are not a parent organization of others? List the organization id.', 'sql_query': 'SELECT organization_id FROM organizations EXCEPT SELECT parent_organization_id FROM organizations', 'db_id': 'local_govt_and_lot', 'hardness': 'hard', 'cot': 'To find organizations that are not parent organizations of others, we can use the EXCEPT keyword in SQL. \n\n- First, we need to select the `organization_id` from the `Organizations` table.\n- We then use the EXCEPT keyword to subtract the `parent_organization_id` from the `Organizations` table.\n- This will give us the organization IDs that do not appear in the `parent_organization_id` column, indicating that they are not parent organizations.\n\nBy executing this query, we will get a list of organization IDs that are not considered parent organizations of other organizations. This approach helps us identify standalone organizations in the database.'}, {'question': "What are the resident details containing the substring 'Miss'?", 'sql_query': "SELECT other_details FROM Residents WHERE other_details LIKE '%Miss%'", 'db_id': 'local_govt_and_lot', 'hardness': 'medium', 'cot': '1. The SQL query is requesting data from the "Residents" table.\n2. The query specifies that we want to retrieve the "other_details" column from the table.\n3. The condition specified in the query is that the "other_details" column should contain the substring \'Miss\'.\n4. The \'%\' symbol in the LIKE clause indicates that \'Miss\' can appear at any position within the "other_details" column value.\n5. By executing this query, the database will return all resident details where the "other_details" column contains the substring \'Miss\'.'}], 'battle_death': [{'question': 'What are the ids and names of the battles that led to more than 10 people killed in total.', 'sql_query': 'SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10', 'db_id': 'battle_death', 'hardness': 'hard', 'cot': '- The SQL query first selects the `id` and `name` columns from the `battle` table, aliasing it as `T1`.\n- It then performs an inner join between the `battle` table (`T1`) and the `ship` table (`T2`) using the condition where the `id` of the battle table matches the `lost_in_battle` field in the ship table.\n- Next, it joins the `ship` table with the `death` table (`T3`) on the condition that the `id` of the ship table matches the `caused_by_ship_id` in the death table.\n- The query groups the results by the `id` of the battle table.\n- Finally, it filters out the groups where the sum of the `killed` column in the `death` table is more than 10 using the `HAVING` clause.\n\nIn summary, the SQL query retrieves the ids and names of battles where the total number of people killed due to ships lost in that battle is more than 10.'}, {'question': 'What is maximum and minimum death toll caused each time?', 'sql_query': 'SELECT max(killed) ,  min(killed) FROM death', 'db_id': 'battle_death', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the maximum and minimum values of the "killed" column from the "death" table.\n2. The "killed" column represents the number of people killed in each death event caused by a ship.\n3. By using the MAX() function, we can retrieve the maximum death toll caused by a single ship in one event.\n4. Similarly, by using the MIN() function, we can retrieve the minimum death toll caused by a single ship in one event.\n5. The query will return the maximum and minimum death tolls caused by a ship in separate columns.'}], 'store_product': [{'question': 'Which city is the headquarter of the store named "Blackville" in?', 'sql_query': 'SELECT t3.headquartered_city FROM store AS t1 JOIN store_district AS t2 ON t1.store_id  =  t2.store_id JOIN district AS t3 ON t2.district_id  =  t3.district_id WHERE t1.store_name  =  "Blackville"', 'db_id': 'store_product', 'hardness': 'hard', 'cot': '- We are selecting the `headquartered_city` column from the `district` table.\n- We are joining the `store` table as `t1` with the `store_district` table as `t2` on the condition where `t1.store_id` is equal to `t2.store_id`.\n- Further, we are performing another join with the `district` table as `t3` on the condition where `t2.district_id` is equal to `t3.district_id`.\n- We are filtering the result by checking the `store_name` column from the `store` table (`t1`) to be equal to "Blackville". This is the store for which we want to find the headquarter city.'}, {'question': 'What is the name of the district with the most residents?', 'sql_query': 'SELECT district_name FROM district ORDER BY city_population DESC LIMIT 1', 'db_id': 'store_product', 'hardness': 'medium', 'cot': '1. Start by accessing the "district" table.\n2. Retrieve the column "district_name" from the table.\n3. Sort the records in descending order based on the column "city_population". This will arrange the districts from the one with the highest population to the one with the lowest population.\n4. Use the "LIMIT 1" clause to restrict the output to only one row, which will give us the district with the most residents.\n5. Execute the query to return the name of the district with the highest population.'}], 'music_1': [{'question': 'What are the different names for all songs that have a higher resolution than English songs?', 'sql_query': 'SELECT DISTINCT song_name FROM song WHERE resolution  >  (SELECT min(resolution) FROM song WHERE languages  =  "english")', 'db_id': 'music_1', 'hardness': 'hard', 'cot': 'The SQL query is selecting distinct song names from the song table where the resolution is greater than the minimum resolution of English songs.\n\n1. The inner query `(SELECT min(resolution) FROM song WHERE languages = "english")` is finding the minimum resolution among English songs.\n   \n2. The outer query `SELECT DISTINCT song_name FROM song WHERE resolution > (... inner query ...)` is then selecting the song names where the resolution is greater than this minimum resolution of English songs.\n\nTherefore, the result will be the names of all songs with a resolution higher than English songs.'}, {'question': 'List the name and country of origin for all singers who have produced songs with rating above 9.', 'sql_query': 'SELECT DISTINCT T1.artist_name ,  T1.country FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.rating  >  9', 'db_id': 'music_1', 'hardness': 'medium', 'cot': 'This SQL query retrieves data from two tables, "artist" and "song", by performing an inner join on the "artist_name" column. The query selects the unique combinations of "artist_name" and "country" from the "artist" table. It filters the results by matching the "artist_name" column between the two tables and includes only those entries where the "rating" in the "song" table is greater than 9. This query essentially lists the names and country of origin for singers who have produced songs with a rating above 9.'}], 'tracking_orders': [{'question': 'For each product, show its name and the number of times it was ordered.', 'sql_query': 'SELECT T3.product_name ,  count(*) FROM orders AS T1 JOIN order_items AS T2 JOIN products AS T3 ON T1.order_id = T2.order_id AND T2.product_id = T3.product_id GROUP BY T3.product_id', 'db_id': 'tracking_orders', 'hardness': 'hard', 'cot': '1. We start by selecting the required columns `product_name` from the `Products` table and using the `count(*)` function to count the number of times each product was ordered.\n\n2. We use the `JOIN` keyword to combine the `Orders` table (aliased as `T1`), the `Order_Items` table (aliased as `T2`), and the `Products` table (aliased as `T3`). \n\n3. We specify the join conditions using the `ON` keyword, connecting the `order_id` from the `Orders` table to the `order_id` from the `Order_Items` table, and connecting the `product_id` from the `Order_Items` table to the `product_id` from the `Products` table.\n\n4. To group the results by each unique product, we use the `GROUP BY` clause with `T3.product_id`.\n\n5. Finally, the query calculates the count of orders for each product by grouping them based on their product ID and selecting the product name and the count of orders.'}, {'question': 'Find the distinct details of invoices which are created before 1989-09-03 or after 2007-12-25.', 'sql_query': 'SELECT DISTINCT invoice_details FROM invoices WHERE invoice_date < "1989-09-03" OR invoice_date > "2007-12-25"', 'db_id': 'tracking_orders', 'hardness': 'medium', 'cot': '- The SQL query is selecting distinct invoice details from the "Invoices" table.\n- The condition for selection is that the invoice date should be before September 3, 1989, or after December 25, 2007, as specified in the WHERE clause.\n- We are using the LESS THAN (<) and GREATER THAN (>) operators with the specified date values to filter the invoices created before 1989-09-03 or after 2007-12-25.\n- The DISTINCT keyword is used to ensure that only unique invoice details are returned, removing any duplicate entries in the result set.'}], 'election': [{'question': 'Show the people that have been comptroller the most times and the corresponding number of times.', 'sql_query': 'SELECT Comptroller ,  COUNT(*) FROM party GROUP BY Comptroller ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'election', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the `Comptroller` column from the `party` table and counting the occurrences of each unique `Comptroller`.\n2. It then groups the results by the `Comptroller` column using the `GROUP BY` clause.\n3. Next, it orders the grouped results by the count of occurrences in descending order using the `ORDER BY COUNT(*) DESC` clause.\n4. Finally, it limits the output to only the first row using `LIMIT 1`, which gives us the person who has been the comptroller the most times and the corresponding number of times.'}, {'question': 'What are the delegate and name of the county they belong to, for each county?', 'sql_query': 'SELECT T2.Delegate ,  T1.County_name FROM county AS T1 JOIN election AS T2 ON T1.County_id  =  T2.District', 'db_id': 'election', 'hardness': 'medium', 'cot': 'This SQL query retrieves the delegate and the name of the county they belong to for each county by performing a join operation between the "county" table aliased as T1 and the "election" table aliased as T2. The join is based on the condition where the County_id in the "county" table matches the District in the "election" table. This allows us to link each county with its corresponding delegate by fetching the Delegate column from the "election" table and the County_name column from the "county" table in the result set.'}], 'music_2': [{'question': 'Who is performing in the back stage position for the song "Der Kapitan"? Show the first name and last name.', 'sql_query': 'SELECT T2.firstname ,  T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId WHERE T3.Title  =  "Der Kapitan" AND T1.StagePosition  =  "back"', 'db_id': 'music_2', 'hardness': 'hard', 'cot': 'To answer the question "Who is performing in the back stage position for the song \'Der Kapitan\'?", we need to retrieve the first name and last name of the band member who is in the back stage position for the specified song.\n\nFirst, we select the first name and last name from the Band table (aliased as T2). We then join the Performance table (aliased as T1) on the Band table using the bandmate id to connect band members to their performances. \n\nNext, we join the Songs table (aliased as T3) on the Performance table using the SongId to link the song information to the performance.\n\nWe then apply the conditions in the WHERE clause. We filter for the specific song "Der Kapitan" by checking the title in the Songs table. Additionally, we specify that we want to find the band member in the back stage position by checking the StagePosition in the Performance table.\n\nFinally, we retrieve the first name and last name of the band member who meets these conditions, giving us the required information about the band member performing in the back stage position for the song "Der Kapitan".'}, {'question': 'Find the number of vocal types used in song "Le Pop"', 'sql_query': 'SELECT count(*) FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid WHERE title  =  "Le Pop"', 'db_id': 'music_2', 'hardness': 'medium', 'cot': 'To find the number of vocal types used in the song "Le Pop," the SQL query first joins the "Vocals" table with the "Songs" table using the condition that the SongId in the "Vocals" table is equal to the SongId in the "Songs" table corresponding to the song title "Le Pop." \n\nThen, the query selects and counts all the different vocal types associated with the song "Le Pop" by counting the rows returned from the join operation. This way, it provides the total number of vocal types used in the song "Le Pop."'}], 'wine_1': [{'question': 'What are the names of wines produced before any wine from the Brander winery?', 'sql_query': 'SELECT Name FROM WINE WHERE YEAR  <  (SELECT min(YEAR) FROM WINE WHERE Winery  =  "Brander")', 'db_id': 'wine_1', 'hardness': 'hard', 'cot': '1. The inner query `(SELECT min(YEAR) FROM WINE WHERE Winery = "Brander")` selects the minimum year amongst all the wines produced by the Brander winery.\n  \n2. The outer query `SELECT Name FROM WINE WHERE YEAR < (...)` retrieves the names of wines where the year produced is less than the minimum year produced by the Brander winery as determined by the inner query.\n\n3. This SQL query will give us the names of wines produced before any wine from the Brander winery.'}, {'question': 'What are the numbers of wines for different grapes?', 'sql_query': 'SELECT count(*) ,  Grape FROM WINE GROUP BY Grape', 'db_id': 'wine_1', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the count of records and the Grape column from the wine table.\n2. The data is grouped by the Grape column, meaning that the count will be calculated for each unique Grape value.\n3. This query will return the number of wines for each different type of grape, providing insights into the distribution of wines based on grape variety.'}], 'formula_1': [{'question': 'Give me a list of names and years of races that had any driver whose forename is Lewis?', 'sql_query': 'SELECT T2.name ,  T2.year FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid JOIN drivers AS T3 ON T1.driverid = T3.driverid WHERE T3.forename = "Lewis"', 'db_id': 'formula_1', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting data from the "results" table aliased as T1.\n2. It then performs an inner join with the "races" table aliased as T2 using the "raceId" column to match data between the two tables.\n3. Another inner join is performed, this time with the "drivers" table aliased as T3 using the "driverId" column to match data between the "results" and "drivers" tables.\n4. The query filters the results to include only data where the forename of the driver in the "drivers" table is equal to "Lewis".\n5. The final result will include the names and years of races that had at least one driver with the forename "Lewis".'}, {'question': 'What are the names of all races held after 2000 in Spain?', 'sql_query': 'SELECT DISTINCT T1.name FROM races AS T1 JOIN circuits AS T2 ON T1.circuitid = T2.circuitid WHERE T2.country = "Spain" AND T1.year > 2000', 'db_id': 'formula_1', 'hardness': 'medium', 'cot': '1. Begin by selecting the distinct names of races from the "races" table, aliased as T1.\n2. Join the "races" table with the "circuits" table, aliased as T2, using the circuitId column to match the circuits hosting the races.\n3. Specify the condition to only include races held in Spain by checking if the country in the circuits table is equal to "Spain".\n4. Further filter the races by ensuring that the year of the race is greater than 2000.\n5. Retrieve and display the names of all the races that meet these conditions.'}], 'sports_competition': [{'question': 'What is the most common competition type?', 'sql_query': 'SELECT Competition_type FROM competition GROUP BY Competition_type ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'sports_competition', 'hardness': 'hard', 'cot': '- The SQL query starts by selecting the "Competition_type" column from the "competition" table.\n- The data is then grouped by the "Competition_type" column using the GROUP BY clause, which means that all rows with the same "Competition_type" will be grouped together.\n- The COUNT(*) function is used to count the number of occurrences of each unique "Competition_type" group.\n- The results are then sorted in descending order of the count of occurrences using the ORDER BY clause.\n- Finally, the LIMIT 1 is used to only return the top row with the highest count, which means we will get the most common competition type.'}, {'question': 'What are the types and countries of competitions?', 'sql_query': 'SELECT Competition_type ,  Country FROM competition', 'db_id': 'sports_competition', 'hardness': 'medium', 'cot': "- The SQL query is selecting the columns 'Competition_type' and 'Country' from the table 'competition'.\n- This query will fetch all the distinct types of competitions along with their respective countries.\n- The 'competition' table contains information about different competitions, including their types and the countries where they took place.\n- By executing this query, we will get a list of unique competition types and the countries associated with each type."}], 'storm_record': [{'question': 'Return the names of the regions affected by storms that had a death count of at least 10.', 'sql_query': 'SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id WHERE T3.number_deaths  >=  10', 'db_id': 'storm_record', 'hardness': 'hard', 'cot': '- The query starts by selecting the table `affected_region` as `T1`, `region` as `T2`, and `storm` as `T3, indicating an intention to retrieve data from these tables.\n- It then proceeds to join `affected_region` with `region` on the `region_id` column, and with `storm` on the `storm_id` column. This helps in connecting the regions affected by storms.\n- The condition `T3.number_deaths >= 10` filters out the results so that only storms with a death count of at least 10 are included in the final output.\n- Finally, the query retrieves and returns the `region_name` from the `region` table for the regions that meet the specified criteria of having storms with a death count of at least 10.'}, {'question': 'What are the names of regions with two or more storms?', 'sql_query': 'SELECT T1.region_name FROM region AS T1 JOIN affected_region AS T2 ON T1.region_id = T2.region_id GROUP BY T1.region_id HAVING count(*)  >=  2', 'db_id': 'storm_record', 'hardness': 'medium', 'cot': '- The query starts by selecting the `region_name` from the `region` table (aliased as T1) and joins it with the `affected_region` table (aliased as T2) using the `region_id` as the common key.\n- The JOIN operation links the two tables based on the `region_id` column to retrieve data related to regions affected by storms.\n- The GROUP BY clause is then used to group the results by the `region_id` from the `region` table.\n- The HAVING clause filters the grouped results to only include those where the count of rows for each group (count(*)) is greater than or equal to 2, indicating that these regions have been affected by two or more storms.\n- As a result, the query will return the names of regions that have experienced the impact of two or more storms.'}], 'tvshow': [{'question': 'What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?', 'sql_query': "SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones')", 'db_id': 'tvshow', 'hardness': 'hard', 'cot': '1. Start by identifying the columns needed from the `TV_Channel` table, which is `package_option`.\n\n2. You want to filter out TV channels that are playing cartoons directed by Ben Jones. To do this, a subquery is used to select the channels from the `Cartoon` table that are directed by Ben Jones.\n\n3. The main query then retrieves the `package_option` from the `TV_Channel` table where the channel ID is not present in the subquery result, indicating TV channels that are not playing any cartoons directed by Ben Jones.'}, {'question': 'Find the package choice and series name of the TV channel that has high definition TV.', 'sql_query': 'SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  "yes"', 'db_id': 'tvshow', 'hardness': 'medium', 'cot': '1. Start by looking at the table "TV_Channel" to find the columns available: "id", "series_name", "Country", "Language", "Content", "Pixel_aspect_ratio_PAR", "Hight_definition_TV", "Pay_per_view_PPV", and "Package_Option".\n  \n2. We are interested in finding the "Package_Option" and "series_name" of the TV channel that has high definition TV.\n\n3. Use the SELECT statement to retrieve the columns "Package_Option" and "series_name" from the "TV_Channel" table.\n\n4. Set the condition in the WHERE clause to filter the rows where the "Hight_definition_TV" column value is "yes" indicating high definition TV.\n\n5. Execute the query to get the desired result which will show the package choice and series name of the TV channel with high definition TV.'}], 'device': [{'question': 'What are the carriers of devices that are not in stock anywhere?', 'sql_query': 'SELECT Carrier FROM device WHERE Device_ID NOT IN (SELECT Device_ID FROM stock)', 'db_id': 'device', 'hardness': 'hard', 'cot': 'We start by looking at the `device` table to retrieve the carriers of devices. \nNext, we use a subquery to filter out those devices which are not present in the `stock` table, i.e., devices that are not in stock anywhere.\nBy using the NOT IN operator, we ensure that only devices not found in the `stock` table are included in the final result.\nThe query then returns the carriers of these devices that are not in stock anywhere.'}, {'question': 'What are the open dates and years for the shop named Apple?', 'sql_query': 'SELECT Open_Date ,  Open_Year FROM shop WHERE Shop_Name  =  "Apple"', 'db_id': 'device', 'hardness': 'medium', 'cot': 'This SQL query is selecting the `Open_Date` and `Open_Year` columns from the `shop` table. The condition `WHERE Shop_Name = "Apple"` is used to filter the results to only show the open dates and years for the shop named "Apple". Only the rows where the `Shop_Name` is "Apple" will be retrieved from the `shop` table.'}], 'university_basketball': [{'question': 'What is the founded year of the non public school that was founded most recently?', 'sql_query': "SELECT founded FROM university WHERE affiliation != 'Public' ORDER BY founded DESC LIMIT 1", 'db_id': 'university_basketball', 'hardness': 'hard', 'cot': '1. Start by looking at the "university" table.\n2. Filter the records to include only non-public schools by checking for an affiliation that is not equal to \'Public\'.\n3. Arrange the filtered results in descending order based on the founded year to find the most recently founded non-public school.\n4. Finally, limit the output to only the most recent founded year by using the LIMIT 1 clause.\n5. The query will return the founded year of the non-public school that was founded most recently.'}, {'question': 'Return the highest acc percent across all basketball matches.', 'sql_query': 'SELECT acc_percent FROM basketball_match ORDER BY acc_percent DESC LIMIT 1', 'db_id': 'university_basketball', 'hardness': 'medium', 'cot': '1. Start by selecting the "acc_percent" column from the "basketball_match" table.\n2. Use the ORDER BY clause with DESC (descending order) to sort the results in descending order based on the "acc_percent" column.\n3. Use the LIMIT 1 clause to only return the highest "acc_percent" value across all basketball matches.\n4. Execute the query to retrieve the highest ACC percent value from the basketball matches.'}], 'bike_1': [{'question': 'What are the names of the stations that are located in Palo Alto but have never been the ending point of the trips', 'sql_query': 'SELECT name FROM station WHERE city  =  "Palo Alto" EXCEPT SELECT end_station_name FROM trip GROUP BY end_station_name HAVING count(*)  >  100', 'db_id': 'bike_1', 'hardness': 'hard', 'cot': "1. We start by selecting the name of the stations from the 'station' table.\n2. We filter the stations based on the condition that they are located in Palo Alto by using the WHERE clause.\n3. To find the stations that have never been the ending point of the trips, we use the EXCEPT keyword to exclude the stations that appear as end stations in the 'trip' table.\n4. We achieve this exclusion by comparing the result of the first SELECT query with the result of the second SELECT query, which retrieves the end station names from the 'trip' table.\n5. In the second SELECT query, we group the end station names and filter them based on a condition using the HAVING clause. The condition ensures that only end station names that have been the ending point of more than 100 trips are included.\n6. The final result will be the names of the stations located in Palo Alto that have never been the ending point of the trips."}, {'question': 'On which day has it neither been foggy nor rained in the zip code of 94107?', 'sql_query': 'SELECT date FROM weather WHERE zip_code  =  94107 AND EVENTS != "Fog" AND EVENTS != "Rain"', 'db_id': 'bike_1', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the date from the weather table.\n2. It is looking for records where the zip code is 94107.\n3. The query includes a condition where the events column is not equal to "Fog" and not equal to "Rain".\n4. By using the logical NOT operator along with the inequality operators, the query is filtering out any records where the weather events are either "Fog" or "Rain".\n5. The result of this query will provide the dates on which it has neither been foggy nor rained in the zip code of 94107.'}], 'shop_membership': [{'question': 'What is the number of branches that have more than the average number of memberships?', 'sql_query': 'SELECT count(*) FROM branch WHERE membership_amount  >  (SELECT avg(membership_amount) FROM branch)', 'db_id': 'shop_membership', 'hardness': 'hard', 'cot': '- The SQL query starts by calculating the average membership amount across all branches using the subquery: `SELECT avg(membership_amount) FROM branch`.\n\n- Next, it compares the membership amount of each branch to this average value in the main query: `SELECT count(*) FROM branch WHERE membership_amount > (SELECT avg(membership_amount) FROM branch)`.\n\n- For each branch, the query checks if the membership amount is greater than the average membership amount. If it is, the branch is included in the count.\n\n- Finally, the query returns the count of branches that have a membership amount greater than the calculated average membership amount.'}, {'question': 'What is the sum of total pounds of purchase in year 2018 for all branches in London?', 'sql_query': "SELECT sum(total_pounds) FROM purchase AS T1 JOIN branch AS T2 ON T1.branch_id  =  T2.branch_id WHERE T2.city  =  'London' AND T1.year  =  2018", 'db_id': 'shop_membership', 'hardness': 'medium', 'cot': "The SQL query starts by selecting the sum of the total pounds from the 'purchase' table (aliased as T1). It then joins this table with the 'branch' table (aliased as T2) on the condition that the branch IDs match between the two tables. \n\nNext, it filters the results by only considering branches located in London by adding a WHERE clause that specifies T2.city equals 'London'. Additionally, it further filters the results by only considering purchases made in the year 2018 by including AND T1.year = 2018 in the WHERE clause.\n\nFinally, the query calculates the sum of total pounds of purchases made in the year 2018 for all branches located in London."}], 'workshop_paper': [{'question': 'Show the colleges that have both authors with submission score larger than 90 and authors with submission score smaller than 80.', 'sql_query': 'SELECT College FROM submission WHERE Scores  >  90 INTERSECT SELECT College FROM submission WHERE Scores  <  80', 'db_id': 'workshop_paper', 'hardness': 'hard', 'cot': 'To find the colleges that have both authors with submission scores larger than 90 and authors with submission scores smaller than 80, we need to first identify the colleges with authors having submission scores larger than 90. This is done by selecting the colleges from the "submission" table where the scores are greater than 90. \n\nNext, we need to identify the colleges with authors having submission scores smaller than 80. This is done by selecting the colleges from the "submission" table where the scores are less than 80.\n\nFinally, we use the INTERSECT operator to combine the results of the two queries. INTERSECT will return only the distinct colleges that appear in both result sets, giving us the colleges that have authors meeting both these criteria.'}, {'question': 'What are the authors of submissions and their colleges?', 'sql_query': 'SELECT Author ,  College FROM submission', 'db_id': 'workshop_paper', 'hardness': 'medium', 'cot': 'This SQL query selects the columns "Author" and "College" from the table "submission". It is used to retrieve the authors of submissions along with their colleges.'}], 'poker_player': [{'question': 'What is the money rank of the tallest poker player?', 'sql_query': 'SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1', 'db_id': 'poker_player', 'hardness': 'hard', 'cot': '- The SQL query begins by selecting the "Money_Rank" column from the "poker_player" table, aliased as T2.\n- It then joins the "poker_player" table with the "people" table, aliased as T1, using the "People_ID" column to match the players with their respective personal information.\n- The JOIN is done to retrieve the information of the tallest poker player, which is determined by sorting the results by the "Height" column in descending order (DESC).\n- The query further limits the output to only return the top (tallest) result using the LIMIT 1 clause.\n- Finally, the query fetches the money rank of the tallest poker player as per the conditions specified in the JOIN and ORDER BY clauses.'}, {'question': 'What are the final tables made and best finishes for all poker players?', 'sql_query': 'SELECT Final_Table_Made ,  Best_Finish FROM poker_player', 'db_id': 'poker_player', 'hardness': 'medium', 'cot': "1. The SQL query is selecting the columns 'Final_Table_Made' and 'Best_Finish' from the 'poker_player' table.\n2. This means that the query will return the values of 'Final_Table_Made' and 'Best_Finish' for all poker players in the database.\n3. Since no specific condition or filter is applied in the query, it will retrieve this information for all poker players without any restrictions.\n4. The query does not involve any joins or aggregations, indicating a straightforward selection of specific columns from a single table."}], 'aircraft': [{'question': 'What are the names of all aicrafts that have never won any match?', 'sql_query': 'SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH)', 'db_id': 'aircraft', 'hardness': 'hard', 'cot': 'To retrieve the names of all aircraft that have never won any match, we need to first identify the aircraft that have won a match. This can be done by selecting the `Winning_Aircraft` from the `match` table.\n\nNext, we can use a subquery to filter out the `Aircraft_ID` from the `aircraft` table that are present in the list of `Winning_Aircraft`. This can be achieved by using the `NOT IN` keyword in the main query to select the `Aircraft` from the `aircraft` table for the aircraft that have never won any match. This will provide us with the names of all aircraft that have never won any match.'}, {'question': 'How many international and domestic passengers are there in the airport London Heathrow?', 'sql_query': 'SELECT International_Passengers ,  Domestic_Passengers FROM airport WHERE Airport_Name  =  "London Heathrow"', 'db_id': 'aircraft', 'hardness': 'medium', 'cot': '1. The SQL query is selecting the columns "International_Passengers" and "Domestic_Passengers" from the table "airport".\n2. The query specifies a condition using the WHERE clause to filter the results based on the "Airport_Name" column being equal to "London Heathrow".\n3. This query will retrieve the number of international and domestic passengers at the airport with the name "London Heathrow".'}], 'railway': [{'question': 'Show the countries that have both managers of age above 50 and managers of age below 46.', 'sql_query': 'SELECT Country FROM manager WHERE Age  >  50 INTERSECT SELECT Country FROM manager WHERE Age  <  46', 'db_id': 'railway', 'hardness': 'hard', 'cot': 'We start by selecting the countries from the manager table where the age of managers is above 50 using the condition "Age > 50". Next, we intersect this result with another select statement where we retrieve the countries from the manager table where the age of managers is below 46 using the condition "Age < 46". By using the INTERSECT operator, we are finding the common countries that have managers with ages above 50 and below 46. Finally, the query will result in displaying the countries that have both managers of age above 50 and managers of age below 46.'}, {'question': 'Show different builders of railways, along with the corresponding number of railways using each builder.', 'sql_query': 'SELECT Builder ,  COUNT(*) FROM railway GROUP BY Builder', 'db_id': 'railway', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the column "Builder" from the "railway" table.\n2. It applies the COUNT(*) function to count the number of rows for each unique value in the "Builder" column.\n3. The results are then grouped by the "Builder" column using the GROUP BY clause.\n4. Finally, the query will display the unique builders of railways along with the corresponding number of railways built by each builder.'}], 'concert_singer': [{'question': 'Show names for all stadiums except for stadiums having a concert in year 2014.', 'sql_query': 'SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014', 'db_id': 'concert_singer', 'hardness': 'hard', 'cot': '1. The SQL query selects the names of all stadiums.\n2. It then excludes the names of stadiums that have a concert in the year 2014.\n3. This is achieved by using the EXCEPT keyword to exclude the names of stadiums that have a concert in the year 2014 from the list of all stadium names.'}, {'question': 'What are the names, countries, and ages for every singer in descending order of age?', 'sql_query': 'SELECT name ,  country ,  age FROM singer ORDER BY age DESC', 'db_id': 'concert_singer', 'hardness': 'medium', 'cot': "1. The SQL query starts by selecting the columns 'name', 'country', and 'age' from the 'singer' table.\n2. The data is retrieved in descending order based on the 'age' column.\n3. The result set will include the names, countries, and ages of every singer, sorted from the oldest to the youngest.\n4. By using the 'ORDER BY' clause with the 'DESC' keyword, the query ensures that the ages are arranged in descending order."}], 'decoration_competition': [{'question': 'Show the most common country across members.', 'sql_query': 'SELECT Country FROM member GROUP BY Country ORDER BY COUNT(*) DESC LIMIT 1', 'db_id': 'decoration_competition', 'hardness': 'hard', 'cot': '1. Start by retrieving data from the "member" table.\n2. Group the rows by the "Country" column.\n3. Count the number of occurrences for each unique country using COUNT(*).\n4. Sort the result in descending order based on the count of members in each country.\n5. Limit the output to only one row, which will give us the most common country across all members.'}, {'question': 'Show the names of members in ascending order of their rank in rounds.', 'sql_query': 'SELECT T1.Name FROM member AS T1 JOIN round AS T2 ON T1.Member_ID  =  T2.Member_ID ORDER BY Rank_in_Round ASC', 'db_id': 'decoration_competition', 'hardness': 'medium', 'cot': '- The SQL query is selecting the name of members from the `member` table and joining it with the `round` table using the `Member_ID` column as the join condition.\n- The `ORDER BY Rank_in_Round ASC` clause sorts the results in ascending order based on the `Rank_in_Round` column.\n- This query fetches the names of members and displays them in ascending order of their ranks in rounds.'}], 'book_2': [{'question': 'List the titles of books that are not published.', 'sql_query': 'SELECT Title FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM publication)', 'db_id': 'book_2', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the attribute "Title" from the table "book".\n\n2. It then specifies a condition in the WHERE clause to filter out books that have a corresponding entry in the "publication" table. This is done by comparing the "Book_ID" in the "book" table with the result of a subquery that selects all "Book_ID" values from the "publication" table.\n\n3. The subquery effectively retrieves all Book_IDs that are already published, and the main query fetches the titles of books whose Book_IDs are not present in this subquery result.\n\n4. As a result, the query will return the titles of books that are not published yet, meaning they do not have any records in the "publication" table indicating that they have been published.'}, {'question': 'List the publisher of the publication with the highest price.', 'sql_query': 'SELECT Publisher FROM publication ORDER BY Price DESC LIMIT 1', 'db_id': 'book_2', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the "Publisher" column from the "publication" table.\n2. It then orders the results in descending order based on the "Price" column.\n3. The query uses the LIMIT clause to limit the result to only one row, which is the first row after ordering by the highest price.\n4. Therefore, the query will return the publisher of the publication with the highest price.'}], 'flight_company': [{'question': 'which pilot is in charge of the most number of flights?', 'sql_query': 'SELECT pilot FROM flight GROUP BY pilot ORDER BY count(*) DESC LIMIT 1', 'db_id': 'flight_company', 'hardness': 'hard', 'cot': '1. We start by looking at the "flight" table that contains information about flights, including the pilot in charge of each flight.\n\n2. We GROUP BY the "pilot" column to group the flights by pilot.\n\n3. We then count the number of flights for each pilot using count(*).\n\n4. Next, we ORDER BY the count of flights in descending order to get the pilot with the most number of flights at the top.\n\n5. Finally, we use LIMIT 1 to only return the pilot who is in charge of the most number of flights. \n\n6. This SQL query will help us identify which pilot is in charge of the most number of flights by analyzing the flight data.'}, {'question': 'What are the names and types of the companies that have ever operated a flight?', 'sql_query': 'SELECT T1.name ,  T1.type FROM operate_company AS T1 JOIN flight AS t2 ON T1.id  =  T2.company_id', 'db_id': 'flight_company', 'hardness': 'medium', 'cot': "1. The SQL query selects the 'name' and 'type' columns from the 'operate_company' table (aliased as T1) and the 'flight' table (aliased as T2).\n2. It uses a JOIN operation to combine the 'operate_company' table with the 'flight' table based on the condition that the 'id' column in 'operate_company' table matches the 'company_id' column in the 'flight' table.\n3. This query retrieves the names and types of the companies that have ever operated a flight by matching the company IDs between the two tables."}], 'party_host': [{'question': 'Show the nations that have both hosts older than 45 and hosts younger than 35.', 'sql_query': 'SELECT Nationality FROM HOST WHERE Age  >  45 INTERSECT SELECT Nationality FROM HOST WHERE Age  <  35', 'db_id': 'party_host', 'hardness': 'hard', 'cot': 'To find the nations that have both hosts older than 45 and hosts younger than 35, we can approach this by first identifying the nationalities of hosts who are older than 45. This is done by selecting the "Nationality" from the "host" table where the "Age" is greater than 45. \n\nNext, we identify the nationalities of hosts who are younger than 35 by selecting the "Nationality" from the "host" table where the "Age" is less than 35.\n\nAfter obtaining the list of nationalities of hosts older than 45 and hosts younger than 35 separately, we use the INTERSECT operator to retrieve the common nationalities that meet both conditions. This will give us the nations that have both hosts older than 45 and hosts younger than 35.'}, {'question': 'For each party, return its theme and the name of its host.', 'sql_query': 'SELECT T3.Party_Theme ,  T2.Name FROM party_host AS T1 JOIN HOST AS T2 ON T1.Host_ID  =  T2.Host_ID JOIN party AS T3 ON T1.Party_ID  =  T3.Party_ID', 'db_id': 'party_host', 'hardness': 'medium', 'cot': 'This SQL query retrieves data from three tables: party_host, host, and party. \n\n1. The query starts by joining the party_host table (aliased as T1) with the host table (aliased as T2) on the condition that the Host_ID in party_host matches the Host_ID in the host table. This allows us to link hosts to their corresponding IDs.\n\n2. Next, the query joins the result of the previous join with the party table (aliased as T3) based on the condition that the Party_ID in party_host matches the Party_ID in the party table. This step links each party to its corresponding ID.\n\n3. Finally, the SELECT statement specifies that the output should include the Party_Theme from the party table (T3) and the Name from the host table (T2). This means that for each party, the query will return its theme along with the name of its host.'}], 'cre_Docs_and_Epenses': [{'question': 'Give the ids of documents that have expenses and contain the letter s in their names.', 'sql_query': "SELECT T1.document_id FROM Documents AS T1 JOIN Documents_with_expenses AS T2 ON T1.document_id  =  T2.document_id WHERE T1.document_name LIKE '%s%'", 'db_id': 'cre_Docs_and_Epenses', 'hardness': 'hard', 'cot': '- We start by looking at the "Documents" table and "Documents_with_Expenses" table as they are the main tables involved in the query.\n- The query uses a JOIN operation to combine these two tables based on the matching "document_id" column.\n- The condition in the WHERE clause filters the results to only include rows where the document name in the "Documents" table contains the letter \'s\'.\n- Finally, the query selects and returns the "document_id" of the documents that meet the specified conditions.'}, {'question': 'Count the number of documents with the type code BK that correspond to each product id.', 'sql_query': 'SELECT count(*) ,  project_id FROM Documents WHERE document_type_code  =  "BK" GROUP BY project_id', 'db_id': 'cre_Docs_and_Epenses', 'hardness': 'medium', 'cot': '1. We start by looking at the "Documents" table which contains information about different documents.\n2. We filter the documents by the condition where the "document_type_code" is equal to "BK". This filters out only the documents with the type code "BK".\n3. We then group the filtered documents by the "project_id" column. This groups together documents that correspond to the same project.\n4. Finally, we count the number of documents in each group (project) using the COUNT(*) function, which gives us the count of documents with the type code "BK" for each project id.'}], 'restaurants': [{'question': 'what are some good restaurants in the yosemite and mono lake area for french food ?', 'sql_query': 'SELECT t3.house_number  ,  t1.name FROM restaurant AS t1 JOIN geographic AS t2 ON t1.city_name  =  t2.city_name JOIN LOCATION AS t3 ON t1.id  =  t3.restaurant_id WHERE t2.region  =  "yosemite and mono lake area" AND t1.food_type  =  "french" AND t1.rating  >  2.5;', 'db_id': 'restaurants', 'hardness': 'hard', 'cot': '1. The query starts by selecting the house_number and name columns from the LOCATION and RESTAURANT tables, aliased as t3 and t1 respectively.\n2. The query then performs a JOIN operation between the RESTAURANT table (aliased as t1) and the GEOGRAPHIC table (aliased as t2) on the condition where the city names match.\n3. Next, the query further JOINs the LOCATION table (aliased as t3) with the previous join result based on the restaurant IDs matching.\n4. The WHERE clause filters the results based on the following conditions:\n   a. t2.region must be equal to "yosemite and mono lake area".\n   b. t1.food_type must be "french".\n   c. t1.rating must be greater than 2.5.\n5. Overall, the query aims to select the house numbers and names of restaurants in the "yosemite and mono lake area" region that serve French food and have a rating greater than 2.5.'}, {'question': 'where can we find a restaurant in alameda ?', 'sql_query': 'SELECT t2.house_number  ,  t1.name FROM restaurant AS t1 JOIN LOCATION AS t2 ON t1.id  =  t2.restaurant_id WHERE t2.city_name  =  "alameda";', 'db_id': 'restaurants', 'hardness': 'medium', 'cot': 'The SQL query retrieves the house number and name of restaurants in Alameda. It does this by joining the "restaurant" table (aliased as t1) with the "location" table (aliased as t2) using the restaurant ID as the key. The query filters the results by selecting only those records where the city name in the location table is "Alameda".'}], 'climbing': [{'question': 'Show the countries that have mountains with height more than 5600 stories and mountains with height less than 5200.', 'sql_query': 'SELECT Country FROM mountain WHERE Height  >  5600 INTERSECT SELECT Country FROM mountain WHERE Height  <  5200', 'db_id': 'climbing', 'hardness': 'hard', 'cot': 'To retrieve the countries that have mountains with a height greater than 5600 and also mountains with a height less than 5200, we need to first select the countries with mountains that have a height greater than 5600 using the SQL query: \n\n```\nSELECT Country FROM mountain WHERE Height > 5600\n```\n\nNext, we need to select the countries with mountains that have a height less than 5200 using the SQL query:\n\n```\nSELECT Country FROM mountain WHERE Height < 5200\n```\n\nFinally, we need to combine the results of these two queries using the INTERSECT operator to find the common countries that satisfy both conditions. The INTERSECT operator will return only the countries that appear in both result sets, providing us with the desired output.'}, {'question': 'Show the distinct names of mountains climbed by climbers from country "West Germany".', 'sql_query': 'SELECT DISTINCT T2.Name FROM climber AS T1 JOIN mountain AS T2 ON T1.Mountain_ID  =  T2.Mountain_ID WHERE T1.Country  =  "West Germany"', 'db_id': 'climbing', 'hardness': 'medium', 'cot': '- We start by selecting data from the "climber" table as T1 and the "mountain" table as T2.\n- We then join these two tables on the condition that the Mountain_ID in T1 matches the Mountain_ID in T2, linking climbers to the mountains they have climbed.\n- The WHERE clause filters the results to only include rows where the climbers are from the country "West Germany".\n- By using the DISTINCT keyword, we ensure that only unique names of mountains climbed by climbers from West Germany are returned in the result set.'}], 'pets_1': [{'question': 'Find the id of students who do not have a cat pet.', 'sql_query': "SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat'", 'db_id': 'pets_1', 'hardness': 'hard', 'cot': "1. The SQL query starts by selecting the `stuid` from the `student` table.\n2. It then uses the `EXCEPT` keyword to exclude the results of the subquery.\n3. The subquery starts by selecting `T1.stuid` from a self-join on the `student` table.\n4. The self-join is done to match students with their pets through the `has_pet` table.\n5. The subquery then includes a join with the `pets` table to get the pet details.\n6. The condition `WHERE T3.pettype = 'cat'` filters the results to only include students who have a cat pet.\n7. By using `EXCEPT`, the main query then retrieves the `stuid` of students who do not have a cat pet."}, {'question': 'Find the type and weight of the youngest pet.', 'sql_query': 'SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1', 'db_id': 'pets_1', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the columns "petType" and "weight" from the table "Pets".\n2. The query then proceeds to order the results by the column "pet_age" in ascending order using the "ORDER BY" clause.\n3. After arranging the data based on the age of the pets, the query limits the results to only the first row using the "LIMIT 1" clause.\n4. Finally, the query will return the pet type and weight of the youngest pet based on the ascending order of their age.'}], 'customers_and_products_contacts': [{'question': 'Show the names of customers who use Credit Card payment method and have more than 2 orders.', 'sql_query': "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id WHERE T1.payment_method_code  =  'Credit Card' GROUP BY T1.customer_id HAVING count(*)  >  2", 'db_id': 'customers_and_products_contacts', 'hardness': 'hard', 'cot': "1. The SQL query begins by selecting the column `customer_name` from the `Customers` table, aliased as `T1`.\n2. It then joins the `Customers` table (`T1`) with the `Customer_Orders` table (`T2`) based on the `customer_id` to match customers with their orders.\n3. The join condition specifies that the `customer_id` in the `Customers` table (`T1`) should be equal to the `customer_id` in the `Customer_Orders` table (`T2`).\n4. The query then filters the results by checking that the `payment_method_code` in the `Customers` table is 'Credit Card'.\n5. The `GROUP BY` clause is used to group the results by `customer_id`, as the query wants to count the number of orders for each customer.\n6. The `HAVING` clause is applied after grouping to filter out only those groups where the count of orders (`count(*)`) is greater than 2.\n7. The final result will show the names of customers who use the Credit Card payment method and have more than 2 orders."}, {'question': 'Show the minimum, maximum, average price for all products.', 'sql_query': 'SELECT min(product_price) ,  max(product_price) ,  avg(product_price) FROM products', 'db_id': 'customers_and_products_contacts', 'hardness': 'medium', 'cot': 'To find the minimum, maximum, and average price for all products, we need to select the minimum, maximum, and average values from the `product_price` column in the `Products` table. \n\n1. The `MIN(product_price)` function will retrieve the minimum price value in the `product_price` column.\n2. The `MAX(product_price)` function will retrieve the maximum price value in the `product_price` column.\n3. The `AVG(product_price)` function will calculate the average price value in the `product_price` column.\n\nBy using these functions and selecting them from the `Products` table, we can obtain the desired information about the prices of all products in the database.'}], 'entrepreneur': [{'question': 'What are the names of people who are not entrepreneurs?', 'sql_query': 'SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM entrepreneur)', 'db_id': 'entrepreneur', 'hardness': 'hard', 'cot': 'This SQL query first selects the column "People_ID" from the "entrepreneur" table. It then filters out the "People_ID" values from the "people" table that are not present in the subquery result. Finally, it retrieves the names of those people who are not entrepreneurs by querying the "Name" column from the "people" table.'}, {'question': 'Return the weight of the shortest person.', 'sql_query': 'SELECT Weight FROM people ORDER BY Height ASC LIMIT 1', 'db_id': 'entrepreneur', 'hardness': 'medium', 'cot': '1. The SQL query selects the "Weight" column from the "people" table.\n2. The "Height" column is sorted in ascending order using the ORDER BY clause.\n3. The LIMIT 1 clause is used to only return the first row after sorting, which corresponds to the shortest person based on their height.\n4. Finally, the query returns the weight of the shortest person from the "people" table.'}], 'mountain_photos': [{'question': 'What is the name of each camera lens and the number of photos taken by it? Order the result by the count of photos.', 'sql_query': 'SELECT T1.name ,  count(*) FROM camera_lens AS T1 JOIN photos AS T2 ON T1.id  =  T2.camera_lens_id GROUP BY T1.id ORDER BY count(*)', 'db_id': 'mountain_photos', 'hardness': 'hard', 'cot': '- This SQL query starts by selecting the name from the camera_lens table (aliased as T1) and the count of photos taken by each camera lens.\n- It then joins the camera_lens table with the photos table (aliased as T2) on the condition that the id in camera_lens matches the camera_lens_id in photos.\n- Next, it groups the result by the id of the camera lens.\n- Finally, it orders the result by the count of photos in ascending order.'}, {'question': "How many distinct kinds of camera lenses are used to take photos of mountains in the country 'Ethiopia'?", 'sql_query': "SELECT count(DISTINCT T2.camera_lens_id) FROM mountain AS T1 JOIN photos AS T2 ON T1.id  =  T2.mountain_id WHERE T1.country  =  'Ethiopia'", 'db_id': 'mountain_photos', 'hardness': 'medium', 'cot': '1. The SQL query starts by joining the "mountain" table (aliased as T1) with the "photos" table (aliased as T2) using the mountain\'s ID (T1.id) and the mountain ID in the photos table (T2.mountain_id).\n\n2. The join is based on the condition where the country in the "mountain" table is \'Ethiopia\' as specified in the WHERE clause (T1.country = \'Ethiopia\').\n\n3. The query then counts the distinct camera lens IDs used to take photos of mountains in Ethiopia. It does this by using the COUNT() function with DISTINCT on the camera_lens_id column from the photos table (T2.camera_lens_id).\n\n4. This query will return the number of distinct kinds of camera lenses used to take photos of mountains in the country \'Ethiopia\'.'}], 'products_for_hire': [{'question': "What are the start date and end date of the booking that has booked the product named 'Book collection A'?", 'sql_query': "SELECT T3.booking_start_date ,   T3.booking_end_date FROM Products_for_hire AS T1 JOIN products_booked AS T2 ON T1.product_id  =  T2.product_id JOIN bookings AS T3 ON T2.booking_id  =  T3.booking_id WHERE T1.product_name  =  'Book collection A'", 'db_id': 'products_for_hire', 'hardness': 'hard', 'cot': "This SQL query is selecting the start date and end date of a booking that has booked the product named 'Book collection A'. To achieve this, it joins the `Products_for_Hire` table with the `Products_Booked` table on the `product_id`, and then joins the `Products_Booked` table with the `Bookings` table on the `booking_id`. It filters the results based on the condition that the `product_name` in the `Products_for_Hire` table is 'Book collection A'. Finally, it selects the `booking_start_date` and `booking_end_date` from the `Bookings` table for the specified product."}, {'question': 'What are the first name, last name, and gender of all the good customers? Order by their last name.', 'sql_query': "SELECT first_name ,  last_name ,  gender_mf FROM customers WHERE good_or_bad_customer  =  'good' ORDER BY last_name", 'db_id': 'products_for_hire', 'hardness': 'medium', 'cot': "- The SQL query is selecting the columns `first_name`, `last_name`, and `gender_mf` from the table `Customers`.\n- It is filtering the results to only include rows where the column `good_or_bad_customer` is equal to 'good'.\n- The query is then ordering the results by the column `last_name`."}], 'journal_committee': [{'question': 'Show the names and ages of editors and the theme of journals for which they serve on committees, in ascending alphabetical order of theme.', 'sql_query': 'SELECT T2.Name ,  T2.age ,  T3.Theme FROM journal_committee AS T1 JOIN editor AS T2 ON T1.Editor_ID  =  T2.Editor_ID JOIN journal AS T3 ON T1.Journal_ID  =  T3.Journal_ID ORDER BY T3.Theme ASC', 'db_id': 'journal_committee', 'hardness': 'hard', 'cot': '1. The SQL query starts by selecting the columns "Name" and "Age" from the "editor" table (aliased as T2) and the column "Theme" from the "journal" table (aliased as T3).\n\n2. The query then performs a JOIN operation between the "journal_committee" table (aliased as T1) and the "editor" table (aliased as T2) using the common column "Editor_ID" to match editors serving on committees.\n\n3. Next, a JOIN operation is performed between the result of the previous JOIN (which now includes editor details) and the "journal" table (aliased as T3) using the common column "Journal_ID" to link the journals that editors are assigned to.\n\n4. The results are ordered in ascending alphabetical order based on the "Theme" column from the "journal" table using ORDER BY Theme ASC.\n\n5. Ultimately, the query retrieves the names and ages of editors along with the themes of the journals for which they serve on committees, sorted in ascending alphabetical order of themes.'}, {'question': 'Show the id, name of each editor and the number of journal committees they are on.', 'sql_query': 'SELECT T1.editor_id ,  T1.Name ,  COUNT(*) FROM editor AS T1 JOIN journal_committee AS T2 ON T1.Editor_ID  =  T2.Editor_ID GROUP BY T1.editor_id', 'db_id': 'journal_committee', 'hardness': 'medium', 'cot': 'This SQL query is selecting the editor_id and name from the editor table (aliased as T1), and counting the number of journal committees each editor is on by joining the editor table with the journal_committee table (aliased as T2) on the Editor_ID. The result set will be grouped by editor_id, so each editor will have a separate row showing their editor_id, name, and the count of journal committees they are on.'}], 'course_teach': [{'question': 'What are the names of the teachers whose courses have not been arranged?', 'sql_query': 'SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange)', 'db_id': 'course_teach', 'hardness': 'hard', 'cot': '1. The SQL query selects the names of teachers from the "teacher" table.\n2. It uses a subquery to get the Teacher_ID values from the "course_arrange" table.\n3. The NOT IN operator is used to filter out the Teacher_ID values that are present in the subquery result.\n4. This means that the query will return the names of teachers whose Teacher_ID values do not appear in the "course_arrange" table, indicating that their courses have not been arranged.'}, {'question': 'What is the hometown of the youngest teacher?', 'sql_query': 'SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1', 'db_id': 'course_teach', 'hardness': 'medium', 'cot': '- The SQL query starts by selecting the column "Hometown" from the table "teacher."\n- It then orders the results by the column "Age" in ascending order, placing the youngest teacher first.\n- Finally, the query uses the LIMIT clause to only return the first row, which corresponds to the youngest teacher.\n- Therefore, the query retrieves the hometown of the youngest teacher from the "teacher" table.'}], 'theme_gallery': [{'question': 'What are the names of artists who did not have an exhibition in 2004?', 'sql_query': 'SELECT name FROM artist EXCEPT SELECT T2.name FROM exhibition AS T1 JOIN artist AS T2 ON T1.artist_id  =  T2.artist_id WHERE T1.year  =  2004', 'db_id': 'theme_gallery', 'hardness': 'hard', 'cot': '1. We want to retrieve the names of artists who did not have an exhibition in 2004.\n2. The query starts with selecting the names from the "artist" table.\n3. It then uses the EXCEPT keyword to exclude the names of artists who had an exhibition in 2004.\n4. To exclude the names of artists who had an exhibition in 2004, it uses a subquery:\n   - The subquery aliases the "exhibition" table as T1 and joins it with the "artist" table aliased as T2 on the artist_id column.\n   - The condition for the join is where the artist_id from the "exhibition" table matches the artist_id from the "artist" table.\n   - It further filters to only include data where the year of the exhibition is 2004.\n5. By using EXCEPT, the query ensures that only the names of artists who did not have an exhibition in 2004 are included in the final result set.'}, {'question': 'Show all artist name, age, and country ordered by the yeared they joined.', 'sql_query': 'SELECT name ,  age ,  country FROM artist ORDER BY Year_Join', 'db_id': 'theme_gallery', 'hardness': 'medium', 'cot': '1. The SQL query starts by selecting the columns `name`, `age`, and `country` from the table `artist`.\n2. The selected columns are then ordered by the `Year_Join` column in ascending order.\n3. This query will retrieve all artist names, ages, and countries from the `artist` table and display them in the order of the year they joined the organization.'}], 'news_report': [{'question': 'Show the names of journalists and the number of events they reported.', 'sql_query': 'SELECT T3.Name ,  COUNT(*) FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID GROUP BY T3.Name', 'db_id': 'news_report', 'hardness': 'hard', 'cot': '1. The query starts by selecting the name from the "journalist" table (aliased as T3) and the count of events each journalist reported.\n2. It then joins the "news_report" table (aliased as T1) with the "event" table (aliased as T2) based on the Event_ID to get the events related to each news report.\n3. Next, it further joins the result of the previous join with the "journalist" table based on journalist_ID to link journalists with their news reports and events.\n4. The data is then grouped by the name of the journalist (T3.Name) to count the number of events each journalist reported.\n5. Finally, the query will return the names of journalists along with the count of events they reported.'}, {'question': 'Show the names of journalists and the dates of the events they reported.', 'sql_query': 'SELECT T3.Name ,  T2.Date FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID', 'db_id': 'news_report', 'hardness': 'medium', 'cot': 'The SQL query is using a SELECT statement to retrieve data from the tables news_report (aliased as T1), event (aliased as T2), and journalist (aliased as T3). \n\n1. The query starts by joining the news_report table (T1) with the event table (T2) on the condition that the Event_ID in T1 matches the Event_ID in T2, linking the events to the news reports for those events.\n2. Next, it further joins the result of the first join with the journalist table (T3) on the condition that the journalist_ID in T1 matches the journalist_ID in T3, connecting the journalists to the news reports they have contributed to.\n3. The SELECT statement specifies that the output should include the Name column from the journalist table (T3) and the Date column from the event table (T2), showing the names of journalists and the dates of the events they reported on.\n\nThis query establishes the relationships between events, news reports, and journalists to fetch the desired information about which journalists reported on which events along with the dates of those events.'}]}